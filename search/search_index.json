{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#what-is-decompose","title":"What is Decompose?","text":"<p>Decompose is a Kotlin Multiplatform library for breaking down your code into lifecycle-aware business logic components (aka BLoC), with routing functionality and pluggable UI (Jetpack Compose, Android Views, SwiftUI, JS React, etc.).</p>"},{"location":"#supported-targets","title":"Supported targets","text":"<ul> <li><code>android</code>,</li> <li><code>jvm</code></li> <li><code>js</code> (both <code>IR</code> and <code>Legacy</code> modes)</li> <li><code>iosX64</code>, <code>iosArm64</code>, <code>iosSimulatorArm64</code></li> <li><code>tvosArm64</code>, <code>tvosX64</code>, <code>tvosSimulatorArm64</code></li> <li><code>watchosArm32</code>, <code>watchosArm64</code>, <code>watchosX64</code>, <code>watchosSimulatorArm64</code></li> <li><code>macosX64</code>, <code>macosArm64</code></li> </ul>"},{"location":"#why-decompose","title":"Why Decompose?","text":"<ul> <li>Decompose draws clear boundaries between UI and non-UI code, which gives the following benefits:<ul> <li>Better separation of concerns</li> <li>Pluggable platform-specific UI (Compose, SwiftUI, React, etc.)</li> <li>Business logic code is testable with pure multiplatform unit tets</li> </ul> </li> <li>Proper dependency injection (DI) and inversion of control (IoC) via constructor, including but not limited to type-safe arguments.</li> <li>Shared navigation logic</li> <li>Lifecycle-aware components</li> <li>Components in the back stack are not destroyed, they continue working in background without UI</li> <li>Components and UI state preservation (mostly useful in Android)</li> <li>Instances retaining (aka ViewModels) over configuration changes (mostly useful in Android)</li> </ul>"},{"location":"samples/","title":"Samples","text":""},{"location":"samples/#multi-feature-sample-app","title":"Multi-Feature Sample App","text":"<p>This sample demonstrates the following features:</p> <ul> <li>Nested reusable components</li> <li>Bottom navigation</li> <li>Nested navigation</li> <li>State preservation (using <code>StateKeeper</code>)</li> <li>Retaining instances (using <code>InstanceKeeper</code>)</li> <li>Pluggable UI (Android Views, Jetpack Compose, SwiftUI, JS React)</li> <li>Play Feature Delivery for Android</li> <li>Tests, including UI tests (Jetpack Compose)</li> </ul> <p>Please note that Gradle files included in this sample project are not supposed to be used as a reference. They share the configuration with the reset of the library, which simplifies the maintenance a lot. Please refer to the KMP documentation for information on configuring a KMP project. You can also check other sample projects described below.</p> <p>Content:</p> <ul> <li>shared - this is a shared module that contains the following components:<ul> <li>Root - the root (top-most) component, it displays the bottom navigation bar and the currently selected tab.</li> <li>Counters - the Counters tab, contains a stack of <code>CounterComponent</code>.<ul> <li>Counter - contains <code>CounterComponent</code>, it just increments the counter every 250 ms. It starts counting once created and stops when destroyed. So <code>CounterComponent</code> continues counting while in the back stack, unless recreated. It uses the <code>InstanceKeeper</code>, so counting continues after Android configuration changes. The <code>StateKeeper</code> is used to preserve the state when the process is recreated on Android.</li> </ul> </li> <li>Cards - the (draggable) Cards tab, contains a stack of [Card] components that can be dragged and thrown to the back of the stack. The top component is resumed and running, and components in the back stack are stopped. This sample demonstrates how the navigation can be controlled by gestures.<ul> <li>Card - contains <code>CardComponent</code> - a draggable card with some text information.</li> </ul> </li> <li>MultiPane - the Multi-Pane tab, it displays <code>ArticleListComponent</code> and <code>ArticleDetailsComponent</code> components either in a stack (one on top of another) or side by side. Please note that this sample is for advanced single-pane/multi-pane navigation and layout, for generic master-detail navigation please refer to the Sample Todo List App described below.<ul> <li>ArticleListComponent - displays a random list of articles. Clicking on an item triggers the <code>ArticleDetails</code> component.</li> <li>ArticleDetailsComponent - displays the content of the selected article.</li> </ul> </li> <li>DynamicFeatures - the Dynamic Features tab, it demonstrates the usage of Play Feature Delivery on Android, while using classing integration on other platforms. There are two simple feature components - <code>Feature1</code> and <code>Feature2</code> - they are located in separate modules described below.<ul> <li>DynamicFeature - a helper component responsible for loading dynamic feature components.</li> </ul> </li> </ul> </li> <li>compose - this module contains Jetpack Compose UI.</li> <li>dynamic-features/api - this module contains only API for dynamic feature components.</li> <li>dynamic-features/compose-api - this module contains only Jetpack Compose API for dynamic feature components.</li> <li>dynamic-features/feature1Impl - contains the implementation of <code>Feature1</code> dynamic feature component. On Android it depends on <code>android-app</code> module and is used via reflection. On all other targets, the <code>shared</code> module directly depends on this module and no reflection is used.</li> <li>dynamic-features/feature2Impl - contains the implementation of <code>Feature2</code> dynamic feature component. On Android it depends on <code>android-app</code> module and is used via reflection. On all other targets, the <code>shared</code> module directly depends on this module and no reflection is used.</li> <li>Android sample app</li> <li>Desktop sample app</li> <li>iOS sample app</li> <li>Web (JS) sample app</li> <li>Tests<ul> <li>RootComponentIntegrationTest - integration tests for <code>RootComponent</code>, including navigation tests.</li> <li>CountersComponentIntegrationTest - integration tests for <code>CountersComponent</code>, including navigation tests.</li> <li>CounterComponentTest - unit tests for <code>CounterComponent</code>. Includes supplying test dependencies, tests for instance retaining and state preservation, etc.</li> <li>CounterContentTest - UI tests (Jetpack Compose) for <code>CounterComponent</code>.</li> </ul> </li> </ul> <p>Warning</p> <p>The Multi-Pane sample is only for advanced single-pane/multi-pane navigation and layout. For generic master-detail navigation please refer to the Sample Todo List App described below.</p>"},{"location":"samples/#component-hierarchy","title":"Component Hierarchy","text":""},{"location":"samples/#counters-screenshots","title":"Counters Screenshots","text":""},{"location":"samples/#multi-pane-screenshots","title":"Multi-Pane Screenshots","text":""},{"location":"samples/#sample-todo-app","title":"Sample Todo App","text":"<p>Simple todo application with a list and detail page that shares UI between Android and desktop with Compose Multiplatform and SwiftUI for iOS. The following libraries are used in this sample: </p> <ul> <li>MVIKotlin - presentation and business logic</li> <li>Reaktive - background processing and data transformation</li> <li>SQLDelight - data storage</li> </ul> <p>TodoAppDecomposeMviKotlin</p> <p></p>"},{"location":"samples/#sample-greetings-app","title":"Sample Greetings App","text":"<p>Sample Greetings Repository</p>"},{"location":"samples/#related-articles","title":"Related Articles","text":"<ul> <li>Decompose \u2014 experiments with Kotlin Multiplatform lifecycle-aware components and navigation</li> <li>Fully cross-platform Kotlin applications (almost)</li> </ul>"},{"location":"component/back-button/","title":"Back button handling","text":"<p>Some devices (e.g. Android) have hardware back buttons. A very common use case is to close the current screen, or the app if there is only one screen in the stack. Another possible use case is to show a confirmation dialog before closing the app.</p>"},{"location":"component/back-button/#navigation-with-back-button","title":"Navigation with back button","text":"<p><code>Child Stack</code> and <code>Child Pages</code> can automatically navigate back when the back button is pressed. All you need to do is to supply the <code>handleBackButton=true</code> argument when you initialize a navigation model.</p> <p>Similarly, <code>Child Slot</code> can automatically dismiss the child component when the back button is pressed. see the Child Slot documentation page for more information.</p>"},{"location":"component/back-button/#manual-back-button-handling","title":"Manual back button handling","text":"<p>The back button can be handled manually using <code>BackHandler</code> (comes from Essenty library), which is provided by <code>ComponentContext</code>. The <code>decompose</code> module adds Essenty's <code>back-handler</code> module as <code>api</code> dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the <code>BackHandler</code> and <code>BackDispatcher</code>.</p>"},{"location":"component/back-button/#usage-example","title":"Usage example","text":"<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.backhandler.BackCallback\n\nclass SomeComponent(\ncomponentContext: ComponentContext\n) : ComponentContext by componentContext {\n\nprivate val backCallback = BackCallback { /* Handle the back button */ }\n\ninit {\nbackHandler.register(backCallback)\n}\n\nprivate fun updateBackCallback() {\n// Set isEnabled to true if you want to override the back button\nbackCallback.isEnabled = true // or false\n}\n}\n</code></pre>"},{"location":"component/back-button/#callback-order","title":"Callback order","text":"<p>By default, registered callbacks are checked in reverse order, the last registered enabled callback is called first. Various navigation models may also register back button callbacks, e.g. <code>Child Stack</code> uses <code>BackHandler</code> to automatically pop the stack on back button press. If you want your callback to be called first, make sure to register it as later as possible. Similarly, if you want your callback to be called last, make sure to register it as early as possible.</p> <p>Since Essenty version <code>1.2.0-alpha</code>, it is also possible to specify a priority for your back callback.</p> <pre><code>// This will make sure your callback is always called first\nprivate val backCallback = BackCallback(priority = Int.MAX_VALUE) { ... }\n\n// This will make sure your callback is always called last\nprivate val backCallback = BackCallback(priority = Int.MIN_VALUE) { ... }\n</code></pre>"},{"location":"component/back-button/#predictive-back-gesture","title":"Predictive Back Gesture","text":"<p>Decompose experimentally supports the new Android Predictive Back Gesture, not only on Android. The UI part is covered by Compose extensions, please see the related docs.</p>"},{"location":"component/child-components/","title":"Child components","text":"<p>Decompose provides ability to organize components as trees, so each parent component is only aware of its immediate children. Hence the name of the library - \"Decompose\". You decompose your project by multiple independent reusable components. When adding a subtree into another place (reusing), you only need to satisfy its top component's dependencies.</p> <p>There are two common ways to work with child components:</p> <ul> <li>Navigation - when you need to dynamically switch child components. Please head to   the Navigation documentation page for more   information.</li> <li>Manually - when you need to add a permanent child component, or to manually control its <code>Lifecycle</code>.</li> </ul>"},{"location":"component/child-components/#adding-a-child-component-manually","title":"Adding a child component manually","text":"<p>A permanent child component should be always instantiated during the initialisation of the parent, and it is automatically destroyed at the end of the parent's lifecycle. It is possible to manually control the lifecycle of a permanent child component, e.g. resume it, pause or stop. But permanent child components must never be destroyed manually.</p> <p>Warning</p> <p>Every child component needs its own <code>ComponentContext</code>. Never pass parent's <code>ComponentContext</code> to children, always use either the navigation or the <code>childContext(...)</code> function.</p> <p>A child <code>ComponentContext</code> can be created using the following extension function:</p> <p><code>ComponentContext.childContext(key: String, lifecycle: Lifecycle? = null): ComponentContext</code></p> Example of a child component without lifecycle control<pre><code>class SomeParent(componentContext: ComponentContext) : ComponentContext by componentContext {\n\nval counter: Counter = Counter(childContext(key = \"Counter\"))\n}\n</code></pre> Example of a child component with lifecycle control<pre><code>class SomeParent(componentContext: ComponentContext) : ComponentContext by componentContext {\n\n// Never destroy the lifecycle of a permanent child component! \nprivate val counterLifecycle = LifecycleRegistry()\n\nval counter: Counter = Counter(childContext(key = \"Counter\", lifecycle = counterLifecycle))\n\nprivate fun resumeCounter() {\ncounterLifecycle.resume()\n}\n\nprivate fun stopCounter() {\ncounterLifecycle.stop()\n}\n}\n</code></pre>"},{"location":"component/custom-component-context/","title":"Custom <code>ComponentContext</code>","text":"<p>If one is needing <code>ComponentContext</code> to have extra functionality that is not already provided. It is possible to create a custom <code>ComponentContext</code> that could be decorated with the desired functionality of your choice. </p>"},{"location":"component/custom-component-context/#create-and-implement-custom-componentcontext","title":"Create and implement custom ComponentContext","text":"<p>For example, to create your own custom <code>ComponentContext</code> one must first create an interface that extends <code>ComponentContext</code> and then provide its implementation. </p> <pre><code>interface AppComponentContext : ComponentContext {\n\n// Custom things here\n\n}\n\nclass DefaultAppComponentContext(\ncomponentContext: ComponentContext,\n// Additional dependencies here\n) : AppComponentContext, ComponentContext by componentContext {\n\n// Custom things implementation here\n}\n</code></pre>"},{"location":"component/custom-component-context/#custom-child-componentcontext","title":"Custom child ComponentContext","text":"<p>The default ComponentContext#childContext extension function returns the default <code>ComponentContext</code>. In order to create custom child <code>ComponentContext</code>, a special extension function is required.</p> <pre><code>fun AppComponentContext.childAppContext(key: String, lifecycle: Lifecycle? = null): AppComponentContext =\nDefaultAppComponentContext(\ncomponentContext = childContext(key = key, lifecycle = lifecycle),\n// Supply additional dependencies here\n)\n</code></pre>"},{"location":"component/custom-component-context/#navigation-with-custom-componentcontext","title":"Navigation with custom ComponentContext","text":"<ul> <li>Using Child Stack</li> <li>Using Child Slot</li> </ul>"},{"location":"component/instance-retaining/","title":"Instance retaining","text":"<p>Sometimes it might be necessary to preserve state or data in a component when it gets destroyed. This commonly used in Android when configuration changes occur. The <code>ComponentContext</code> interface extends the <code>InstanceKeeperOwner</code> interface, which provides the <code>InstanceKeeper</code> - a multiplatform abstraction for instances retaining. It is provided by Essenty library (from the same author).</p> <p>The <code>decompose</code> module adds Essenty's <code>instance-keeper</code> module as <code>api</code> dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the <code>InstanceKeeper</code>.</p>"},{"location":"component/instance-retaining/#usage-example","title":"Usage example","text":"<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.getOrCreate\n\nclass SomeComponent(\ncomponentContext: ComponentContext\n) : ComponentContext by componentContext {\n\nprivate val someLogic = instanceKeeper.getOrCreate(::SomeLogic)\n\n/*\n     * Instances of this class will be retained.\n     * \u26a0\ufe0f Pay attention to not leak any dependencies.\n     */\nprivate class SomeLogic : InstanceKeeper.Instance {\noverride fun onDestroy() {\n// Clean-up\n}\n}\n}\n</code></pre>"},{"location":"component/instance-retaining/#retained-components-since-v210-alpha-03","title":"Retained components (since v2.1.0-alpha-03)","text":"<p>Although discouraged, it is still possible to have all components retained over configuration changes on Android. On the one hand, this makes <code>InstanceKeeper</code> no longer required. But on the other hand, this prevents from supplying dependencies that capture the hosting <code>Activity</code> or <code>Fragment</code>.</p> <p>Warning</p> <p>Pay attention when supplying dependencies to a retained component to avoid leaking the hosting <code>Activity</code> or <code>Fragment</code>.</p> <pre><code>class MainActivity : AppCompatActivity() {\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\n\nval root = retainedComponent { componentContext -&gt;\nDefaultRootComponent(componentContext)\n}\n}\n}\n</code></pre>"},{"location":"component/lifecycle/","title":"Lifecycle","text":"<p>The component lifecycle is very similar to the Android Activity lifecycle. The <code>ComponentContext</code> interface extends the <code>LifecycleOwner</code> interface, which provides the <code>Lifecycle</code> - a multiplatform abstraction for lifecycle states and events. It is provided by Essenty library (from the same author).</p> <p>The <code>decompose</code> module adds Essenty's <code>lifecycle</code> module as <code>api</code> dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the <code>Lifecycle</code>.</p> <p>Each component has its own lifecycle. The lifecycle of a child component can not be longer than its parent's lifecycle.</p> <p></p>"},{"location":"component/lifecycle/#usage-example","title":"Usage example","text":"<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.lifecycle.Lifecycle\nimport com.arkivanov.essenty.lifecycle.doOnCreate\nimport com.arkivanov.essenty.lifecycle.subscribe\n\nclass SomeComponent(\ncomponentContext: ComponentContext\n) : ComponentContext by componentContext {\n\ninit {\nlifecycle.subscribe(\nobject : Lifecycle.Callbacks {\noverride fun onCreate() {\n/* Component created */\n}\n\n// onStart, onResume, onPause, onStop, onDestroy\n}\n)\n\nlifecycle.subscribe(\nonCreate = { /* Component created */ },\n// onStart, onResume, onPause, onStop, onDestroy\n)\n\nlifecycle.doOnCreate { /* Component created */ }\n// doOnStart, doOnResume, doOnPause, doOnStop, doOnDestroy\n}\n}\n</code></pre>"},{"location":"component/lifecycle/#managing-the-root-lifecycle","title":"Managing the root lifecycle","text":"<p>When creating a root component, it's required to supply the root lifecycle (see the docs for more information about the root <code>ComponentContext</code>). The way how the root lifecycle is controlled depends on the platform. See Quick Start docs for details and examples.</p>"},{"location":"component/overview/","title":"Component Overview","text":"<p>A component is just a normal class that encapsulates some logic and possibly another (child) components. Every component has its own lifecycle, which is automatically managed by Decompose. So everything encapsulated by a component is scoped. Please head to the Lifecycle documentation page for more information.</p> <p>UI is optional and is pluggable from outside of components. Components do not depend on UI, the UI depends on components.</p>"},{"location":"component/overview/#component-hierarchy","title":"Component hierarchy","text":""},{"location":"component/overview/#pluggable-ui-hierarchy","title":"Pluggable UI hierarchy","text":""},{"location":"component/overview/#typical-component-structure","title":"Typical component structure","text":""},{"location":"component/overview/#componentcontext","title":"ComponentContext","text":"<p>Each component has an associated <code>ComponentContext</code> which implements the following interfaces:</p> <ul> <li><code>LifecycleOwner</code>, provided by Essenty library, so each component has its own lifecycle</li> <li><code>StateKeeperOwner</code>, provided by Essenty library, so you can preserve any state during configuration changes and/or process death</li> <li><code>InstanceKeeperOwner</code>, provided by Essenty library, so you can retain arbitrary object instances in your components (like with AndroidX ViewModels)</li> <li><code>BackHandlerOwner</code>, provided by Essenty library, so each component can handle back button events</li> </ul> <p>So if a component requires any of the above features, just pass the <code>ComponentContext</code> via the component's constructor. You can use the delegation pattern to add the <code>ComponentContext</code> to <code>this</code> scope:</p> <pre><code>class Counter(\ncomponentContext: ComponentContext\n) : ComponentContext by componentContext {\n\n// The rest of the code\n}\n</code></pre>"},{"location":"component/overview/#root-componentcontext","title":"Root ComponentContext","text":"<p>When instantiating a root component, the <code>ComponentContext</code> should be created manually. There is DefaultComponentContext which is the default implementation class of the <code>ComponentContext</code>.</p> <p>Warning</p> <p>The root <code>ComponentContext</code> and the root component should be always created on the UI thread.</p>"},{"location":"component/overview/#root-componentcontext-in-android","title":"Root ComponentContext in Android","text":"<p>Decompose provides a few handy helper functions for creating the root <code>ComponentContext</code> in Android. The preferred way is to create the root <code>ComponentContext</code> in an <code>Activity</code> or a <code>Fragment</code>.</p>"},{"location":"component/overview/#root-componentcontext-in-activity","title":"Root ComponentContext in Activity","text":"<p>For this case Decompose provides <code>defaultComponentContext()</code> extension function, which can be called in scope of an <code>Activity</code>.</p> <pre><code>class MainActivity : AppCompatActivity() {\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\n\nval root = DefaultRootComponent(defaultComponentContext())\n}\n}\n</code></pre>"},{"location":"component/overview/#root-componentcontext-in-fragment","title":"Root ComponentContext in Fragment","text":"<p>Use <code>defaultComponentContext(OnBackPressedDispatcher?)</code> extension function, which can be called in scope of <code>Fragment</code>.</p> <pre><code>class SomeFragment : Fragment() {\nprivate lateinit var root: RootComponent\n\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\n\nroot =\nDefaultRootComponent(\ncomponentContext = defaultComponentContext(\nonBackPressedDispatcher = requireActivity().onBackPressedDispatcher\n)\n)\n}\n}\n</code></pre>"},{"location":"component/overview/#root-componentcontext-in-jetpackjetbrains-compose","title":"Root ComponentContext in Jetpack/JetBrains Compose","text":"<p>It is advised to not create the root <code>ComponentContext</code> (and a root component) directly in a <code>Composable</code> function. Compositions may be performed in a background thread, which may break things. The preferred way is to create the root component on the UI thread outside of Compose.</p> <p>Warning</p> <p>If you can't avoid creating the root component in a <code>Composable</code> function, please make sure you use <code>remember</code>. This will prevent the root component and its <code>ComponentContext</code> from being recreated on each composition.</p>"},{"location":"component/overview/#android-with-compose","title":"Android with Compose","text":"<p>Prefer creating the root <code>ComponentContext</code> (and a root component) before starting Compose, e.g. in an <code>Activity</code> or a <code>Fragment</code>.</p> <pre><code>class MainActivity : AppCompatActivity() {\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\n\n// Create the root component before starting Compose\nval root = DefaultRootComponent(componentContext = defaultComponentContext())\n\n// Start Compose\nsetContent {\n// The rest of the code\n}\n}\n}\n</code></pre>"},{"location":"component/overview/#jvmdesktop-with-compose","title":"JVM/Desktop with Compose","text":"<p>Make sure you always create the root component on the UI thread. Please refer to samples for an example of runOnUiThread function .</p> <pre><code>fun main() {\n// Create the root component on the UI thread before starting Compose\nval root = runOnUiThread { DefaultRootComponent(componentContext = DefaultComponentContext(...)) }\n\n// Start Compose\napplication {\n// The rest of the code\n}\n}\n</code></pre>"},{"location":"component/overview/#other-platforms-with-compose","title":"Other platforms with Compose","text":"<p>Prefer creating the root <code>ComponentContext</code> (and a root component) before starting Compose, e.g. in directly in the <code>main</code> function.</p> <pre><code>fun main() {\n// Create the root component before starting Compose.\n// Make sure that this happens on the UI thread.\nval root = DefaultRootComponent(componentContext = DefaultComponentContext(...))\n\n// Start Compose\napplication {\n// The rest of the code\n}\n}\n</code></pre>"},{"location":"component/overview/#value-and-mutablevalue-state-holders","title":"Value and MutableValue state holders","text":"<p>Value - is a multiplatform way to expose streams of states. It contains the <code>value</code> property, which always returns the current state. It also provides the ability to observe state changes via <code>subscribe</code>/<code>unsubscribe</code> methods. There is MutableValue which is a mutable variant of <code>Value</code>. Since <code>Value</code> is a class (not an interface) with a generic type parameter, it can be used to expose state streams to ObjC/Swift.</p> <p>Using <code>Value</code> is not mandatory, you can use any other state holders, e.g. StateFlow, State, Observable, LiveData, etc.</p> <p>If you are using Jetpack/JetBrains Compose, <code>Value</code> can be observed in Composable functions using one of the Compose extension modules.</p> <p>Warning</p> <p>Even though both <code>Value</code> and <code>MutableValue</code> are thread-safe, it's recommended to subscribe and update it only on the main thread.</p>"},{"location":"component/overview/#why-not-stateflow","title":"Why not StateFlow?","text":"<p>Decompose uses <code>Value</code> to avoid dependency on Kotlin coroutines. One may prefer using Reaktive, RxJava, etc. instead of coroutines. It also provides better interoperability with ObjC/Swift and simplifies testing. Feel free to convert <code>Value</code> to <code>StateFlow</code> or any other state holder if you need it.</p>"},{"location":"component/overview/#examples","title":"Examples","text":""},{"location":"component/overview/#simplest-component-example","title":"Simplest Component Example","text":"<p>Here is an example of simple Counter component:</p> <pre><code>class Counter {\nprivate val _state = MutableValue(State())\nval state: Value&lt;State&gt; = _state\n\nfun increment() {\n_state.update { it.copy(count = it.count + 1) }\n}\n\ndata class State(val count: Int = 0)\n}\n</code></pre>"},{"location":"component/overview/#jetpackjetbrains-compose-ui-example","title":"Jetpack/JetBrains Compose UI Example","text":"<pre><code>@Composable\nfun CounterUi(counter: Counter) {\nval state by counter.state.subscribeAsState()\n\nColumn {\nText(text = state.count.toString())\n\nButton(onClick = counter::increment) {\nText(\"Increment\")\n}\n}\n}\n</code></pre>"},{"location":"component/overview/#swiftui-example","title":"SwiftUI Example","text":"<pre><code>struct CounterView: View {\n    private let counter: Counter\n\n    @StateValue\n    private var state: CounterState\n\n    init(_ counter: Counter) {\n        self.counter = counter\n        _state = StateValue(counter.state)\n    }\n\n    var body: some View {\n        VStack(spacing: 8) {\n            Text(state.value.text)\n            Button(action: counter.increment, label: { Text(\"Increment\") })\n        }\n    }\n}\n</code></pre>"},{"location":"component/overview/#what-is-statevalue","title":"What is StateValue","text":"<p>StateValue is a property wrapper for <code>Value</code> that makes it observable in SwiftUI. Unfortunately it does not look possible to publish utils for SwiftUI as a library or framework, so it has to be copied in your project.</p>"},{"location":"component/overview/#more-swift-utilities","title":"More Swift utilities","text":"<p>You can find more useful utilities for SwiftUI in the DecomposeHelpers/ folder:</p> <ul> <li>StackView - an adapter for SwiftUI's <code>NavigationStack</code> with fallback to <code>UINavigationView</code> that works with Decompose's <code>ChildStack</code>. See CountersView.swift.</li> <li>MutableValue - helps to stub Decompose's <code>Value</code>/<code>MutableValue</code> for Preview Components. See <code>PreviewMultiPaneComponent</code> in MultiPaneView.swift.</li> <li>SimpleChildStack - helps to stub Decompose's <code>ChildStack</code> for Preview Components. See <code>PreviewCountersComponent</code> in CountersView.swift.</li> </ul>"},{"location":"component/scopes/","title":"Scoping jobs and subscriptions","text":"<p>Due to the fact that components are lifecycle-aware, it is very easy to manage coroutine scopes and reactive subscriptions.</p>"},{"location":"component/scopes/#creating-a-coroutinescope-in-a-component","title":"Creating a CoroutineScope in a component","text":"<pre><code>fun CoroutineScope(context: CoroutineContext, lifecycle: Lifecycle): CoroutineScope {\nval scope = CoroutineScope(context)\nlifecycle.doOnDestroy(scope::cancel)\nreturn scope\n}\n\nfun LifecycleOwner.coroutineScope(context: CoroutineContext): CoroutineScope =\nCoroutineScope(context, lifecycle)\n\nclass SomeComponent(\ncomponentContext: ComponentContext,\nmainContext: CoroutineContext,\nprivate val ioContext: CoroutineContext,\n) : ComponentContext by componentContext {\n\n// The scope is automatically cancelled when the component is destroyed\nprivate val scope = coroutineScope(mainContext + SupervisorJob())\n\nfun foo() {\nscope.launch {\nval result =\nwithContext(ioContext) {\n\"Result\" // Result from background thread\n}\n\nprintln(result) // Handle the result on main thread\n}\n}\n}\n</code></pre>"},{"location":"component/scopes/#creating-a-coroutinescope-that-survives-android-configuration-changes","title":"Creating a CoroutineScope that survives Android configuration changes","text":"<pre><code>internal class SomeRetainedInstance(mainContext: CoroutineContext) : InstanceKeeper.Instance {\n// The scope survives Android configuration changes\nprivate val scope = CoroutineScope(mainContext + SupervisorJob())\n\nfun foo() {\nscope.launch {\n// Do the job\n}\n}\n\noverride fun onDestroy() {\nscope.cancel() // Cancel the scope when the instance is destroyed\n}\n}\n\nclass SomeComponent(\ncomponentContext: ComponentContext,\nmainContext: CoroutineContext,\n) : ComponentContext by componentContext {\n\nprivate val someRetainedInstance = instanceKeeper.getOrCreate { SomeRetainedInstance(mainContext) }\n}\n</code></pre>"},{"location":"component/scopes/#creating-a-reaktive-disposablescope-in-a-component","title":"Creating a Reaktive DisposableScope in a component","text":"<pre><code>fun DisposableScope(lifecycle: Lifecycle): DisposableScope {\nval scope = DisposableScope()\nlifecycle.doOnDestroy(scope::dispose)\nreturn scope\n}\n\nfun LifecycleOwner.disposableScope(): DisposableScope =\nDisposableScope(lifecycle)\n\nclass SomeComponent(\ncomponentContext: ComponentContext,\n) : ComponentContext by componentContext,\n// The scope is automatically disposed when the component is destroyed\nDisposableScope by componentContext.disposableScope() {\n\nfun foo() {\nsingleFromFunction {\n\"Result\" // Result from background thread\n}\n.subscribeOn(ioScheduler)\n.observeOn(mainScheduler)\n.subscribeScoped { // Subscribe using the DisposableScope\nprintln(it) // Handle the result on main thread\n}\n}\n}\n</code></pre>"},{"location":"component/scopes/#creating-a-reaktive-disposablescope-that-survives-android-configuration-changes","title":"Creating a Reaktive DisposableScope that survives Android configuration changes","text":"<pre><code>internal class SomeRetainedInstance : InstanceKeeper.Instance,\n// The scope survives Android configuration changes\nDisposableScope by DisposableScope() {\n\nfun foo() {\ncompletableFromFunction {\n// Do the job\n}.subscribeScoped()\n}\n\noverride fun onDestroy() {\ndispose() // Dispose the scope when the instance is destroyed\n}\n}\n\nclass SomeComponent(\ncomponentContext: ComponentContext,\n) : ComponentContext by componentContext {\n\nprivate val someRetainedInstance = instanceKeeper.getOrCreate { SomeRetainedInstance() }\n}\n</code></pre>"},{"location":"component/state-preservation/","title":"State preservation","text":"<p>Sometimes it might be necessary to preserve state or data in a component when it gets destroyed. A very common use case is Android Activity recreation due to configuration changes, or process death on Android or iOS. The <code>ComponentContext</code> interface extends the <code>StateKeeperOwner</code> interface, which provides the <code>StateKeeper</code> - a multiplatform abstraction for state preservation. It is provided by Essenty library (from the same author).</p> <p>The <code>decompose</code> module adds Essenty's <code>state-keeper</code> module as <code>api</code> dependency, so you don't need to explicitly add it to your project. Please familiarise yourself with Essenty library, especially with the <code>StateKeeper</code>.</p>"},{"location":"component/state-preservation/#usage-examples","title":"Usage examples","text":"Saving state in a component<pre><code>import com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.essenty.parcelable.Parcelable\nimport com.arkivanov.essenty.parcelable.Parcelize\nimport com.arkivanov.essenty.statekeeper.consume\n\nclass SomeComponent(\ncomponentContext: ComponentContext\n) : ComponentContext by componentContext {\n\nprivate var state: State = stateKeeper.consume(key = \"SAVED_STATE\") ?: State()\n\ninit {\nstateKeeper.register(key = \"SAVED_STATE\") { state }\n}\n\n@Parcelize\nprivate class State(val someValue: Int = 0) : Parcelable\n}\n</code></pre> Saving state of a retained instance<pre><code>import com.arkivanov.essenty.instancekeeper.InstanceKeeper\nimport com.arkivanov.essenty.instancekeeper.getOrCreate\nimport com.arkivanov.essenty.parcelable.Parcelable\nimport com.arkivanov.essenty.parcelable.ParcelableContainer\nimport com.arkivanov.essenty.parcelable.Parcelize\nimport com.arkivanov.essenty.parcelable.consume\nimport com.arkivanov.essenty.statekeeper.consume\n\nclass SomeComponent(\ncomponentContext: ComponentContext\n) : ComponentContext by componentContext {\n\nprivate val statefulEntity =\ninstanceKeeper.getOrCreate {\nSomeStatefulEntity(savedState = stateKeeper.consume(key = \"SAVED_STATE\"))\n}\n\ninit {\nstateKeeper.register(key = \"SAVED_STATE\", supplier = statefulEntity::saveState)\n}\n}\n\nclass SomeStatefulEntity(\nsavedState: ParcelableContainer?,\n) : InstanceKeeper.Instance {\n\nvar state: State = savedState?.consume() ?: State()\nprivate set\n\nfun saveState(): ParcelableContainer =\nParcelableContainer(state)\n\noverride fun onDestroy() {}\n\n@Parcelize\ndata class State(val someValue: Int = 0) : Parcelable\n}\n</code></pre>"},{"location":"component/state-preservation/#darwin-apple-targets-support","title":"Darwin (Apple) targets support","text":"<p>Decompose provides an experimental support of state preservation for all Darwin (Apple) targets. It works via <code>Essenty</code> library and parcelize-darwin compiler plugin (from the same author). Please read the documentation of both before using state preservation on Darwin targets.</p> <p>This only affects your project if you explicitly enable the <code>parcelize-darwin</code> compiler plugin in your project. Otherwise, it's just no-op.</p> <p>Please refer to the sample iOS app where you can find an example of preserving the state.</p>"},{"location":"component/state-preservation/#jvmdesktop-support","title":"JVM/desktop support","text":"<p>Decompose also provides an experimental support of state preservation for JVM/desktop. Similarly to other targets, it works via <code>Essenty</code> library. Currently, there is no <code>Parcelize</code> compiler plugin, <code>Parcelable</code> interface just extends <code>java.io.Serializable</code>.</p> <p>Due to KT-40218, deserialized <code>object</code> classes are not equal to their original instances. This prevents the navigation state from being restored correctly when a configuration is an <code>object</code>. This will be fixed with the introduction of <code>data object</code> in Kotlin 1.9 (see KT-4107). A workaround for now is to add a readResolve method to every <code>object</code> configuration (see an example).</p> <p>Please refer to the sample JVM/desktop app where you can find an example of preserving the state.</p>"},{"location":"extensions/android/","title":"Extensions for Android views","text":"<p>Experimental extensions and utilities for easier integration of Decompose with Android views.</p>"},{"location":"extensions/android/#setup","title":"Setup","text":"<p>Extensions for Android views are provided by the <code>extensions-android</code> module.</p> GroovyKotlin <pre><code>implementation \"com.arkivanov.decompose:extensions-android:&lt;version&gt;\"\n</code></pre> <pre><code>implementation(\"com.arkivanov.decompose:extensions-android:&lt;version&gt;\")\n</code></pre>"},{"location":"extensions/android/#content","title":"Content","text":"<p>Decompose is primarily designed for better integration with declarative UI frameworks, such as Jetpack/JetBrains Compose, SwiftUI, React, etc. However it still can be used with Android views. Because the main Decompose functionality is separate from UI, the latter has to be plugged externally. This module provides some essential extensions and utilities to improve the experience.</p>"},{"location":"extensions/android/#viewcontext","title":"ViewContext","text":"<p>As mentioned before, Decompose is not aware of any UI. Because the UI is plugged externally, it needs its own <code>Lifecycle</code>. The idea is to supply every view sub-tree with ViewContext, which exposes the following properties:</p> <p><code>parent</code> - a <code>ViewGroup</code> where the view sub-tree should be inflated <code>lifecycle</code> - a <code>Lifecycle</code> of the view sub-tree</p> <p>The following <code>ViewContext</code> extensions are available:</p> <ul> <li><code>val ViewContext.context: Context</code> - returns the Android <code>Context</code> of the view sub-tree</li> <li><code>val ViewContext.resources: Resources</code> - returns the Android <code>Resources</code> of the view sub-tree</li> <li><code>val ViewContext.layoutInflater: LayoutInflater</code> - returns the Android <code>LayoutInflater</code></li> <li><code>fun ViewContext.child(ViewGroup, inflater): ViewContext</code> - creates a child <code>ViewContext</code> with another <code>parent</code> <code>ViewGroup</code>, which shares the <code>Lifecycle</code> of the parent <code>ViewContext</code>. The <code>inflater</code> arguments should inflate a sub-tree of views, but without adding it to the <code>parent</code>.</li> </ul> <p>DefaultViewContext - is a default implementation of <code>ViewContext</code>, which can be used to manually create new instances when needed.</p>"},{"location":"extensions/android/#stackrouterview","title":"StackRouterView","text":"<p>StackRouterView is an Android <code>ViewGroup</code> which observes the <code>Child Stack</code> and manages child views. Once <code>StackRouterView</code> is added to the view hierarchy, just call its <code>children(...)</code> method with the following arguments:</p> <ul> <li><code>stack</code> - the observable <code>Value</code> of <code>ChildStack</code></li> <li><code>lifecycle</code> - the lifecycle of the <code>StackRouterView</code> or its closest parent</li> <li><code>replaceChildView</code> - a function which replaces a currently active child view with a new one, this is also the place where transitions can be applied</li> </ul>"},{"location":"extensions/android/#examples","title":"Examples","text":"<p>You can find an example of using this extension module in the Counter sample.</p> <p>Initializing the root in <code>Activity</code>:</p> <pre><code>override fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\n\nsetContentView(R.layout.main_activity)\n\nval root = CounterRootComponent(defaultComponentContext())\n\nval viewContext =\nDefaultViewContext(\nparent = findViewById(R.id.content),\nlifecycle = essentyLifecycle()\n)\n\nviewContext.apply {\nchild(parent) {\nCounterRootView(root)\n}\n}\n}\n</code></pre> <p>A simple child view:</p> <pre><code>fun ViewContext.CounterView(counter: Counter): View {\n// Inflate the layout without adding it to the parent\nval layout = layoutInflater.inflate(R.layout.counter, parent, false)\n\n// Find required views\nval counterText: TextView = layout.findViewById(R.id.text_count)\n\n// Observe Counter models and update the view\ncounter.model.observe(lifecycle) { data -&gt;\ncounterText.text = data.text\n}\n\nreturn layout // Return the root of the inflated sub-tree\n}\n</code></pre> <p><code>StackRouterView</code> example:</p> <pre><code>fun ViewContext.CounterRootView(counterRoot: CounterRoot): View {\nval layout = layoutInflater.inflate(R.layout.counter_root, parent, false)\nval nextButton: View = layout.findViewById(R.id.button_next)\nval routerView: StackRouterView = layout.findViewById(R.id.router)\n\nnextButton.setOnClickListener { counterRoot.onNextChild() }\n\n// Create a child `ViewContext` for the `CounterView`\nchild(layout.findViewById(R.id.container_counter)) {\n// Reuse the `CounterView`\nCounterView(counterRoot.counter)\n}\n\n// Subscribe the `StackRouterView` to the `ChildStack` changes\nrouterView.children(counterRoot.childStack, lifecycle) { parent, newStack, _ -&gt;\n// Remove all existing views\nparent.removeAllViews()\n\n// Add the child view for the currently active child component\nparent.addView(CounterView(newStack.active.instance))\n}\n\nreturn layout\n}\n</code></pre>"},{"location":"extensions/compose/","title":"Extensions for Jetpack/JetBrains Compose","text":"<p>Extensions and utilities for easier integration of Decompose with Jetpack/JetBrains Compose.</p>"},{"location":"extensions/compose/#setup","title":"Setup","text":"<p>Please see the corresponding Installation docs section.</p>"},{"location":"extensions/compose/#proguard-rules-for-compose-for-desktop-jvm","title":"ProGuard rules for Compose for Desktop (JVM)","text":"<p>If you support Compose for Desktop, you will need to add the following rule for ProGuard, so that the app works correctly in release mode. See Minification &amp; obfuscation section in Compose docs for more information.</p> <pre><code>-keep class com.arkivanov.decompose.extensions.compose.jetbrains.mainthread.SwingMainThreadChecker\n</code></pre>"},{"location":"extensions/compose/#converting-value-to-state","title":"Converting Value to State","text":"<p>To convert Decompose Value to Compose <code>State</code> use <code>Value&lt;T&gt;.subscribeAsState(): State&lt;T&gt;</code> extension function:</p> <pre><code>interface SomeComponent {\nval model: Value&lt;Model&gt;\n\ndata class Model(/*...*/)\n}\n\n@Composable\nfun SomeContent(component: SomeComponent) {\nval model: State&lt;Model&gt; by component.model.subscribeAsState()\n}\n</code></pre>"},{"location":"extensions/compose/#controlling-the-lifecycle-on-desktop","title":"Controlling the Lifecycle on Desktop","text":"<p>When using JetBrains Compose, you can have a <code>LifecycleRegistry</code> react to changes in the window state using the <code>LifecycleController()</code> composable. This will trigger appropriate lifecycle events when the window is minimized, restored or closed.</p> <p>It is also possible to manually start the lifecycle using <code>LifecycleRegistry.resume()</code> when the instance is created.</p> <pre><code>fun main() {\nval lifecycle = LifecycleRegistry()\nval root = RootComponent(DefaultComponentContext(lifecycle))\n\n// Alternative: manually start the lifecycle (no reaction to window state)\n// lifecycle.resume()\n\napplication {\nval windowState = rememberWindowState()\n\n// Bind the registry to the life cycle of the window\nLifecycleController(lifecycle, windowState)\n\nWindow(state = windowState, ...) {\n// The rest of your content\n}\n}\n}\n</code></pre> <p>Warning</p> <p>When using Compose in desktop platforms, make sure to always use one of the methods above, or your components might not receive lifecycle events correctly.</p>"},{"location":"extensions/compose/#navigating-between-composable-components","title":"Navigating between Composable components","text":"<p>The Child Stack navigation model provides ChildStack as <code>Value&lt;ChildStack&gt;</code> that can be observed in a <code>Composable</code> component. This makes it possible to switch child <code>Composable</code> components following the <code>ChildStack</code> changes.</p> <p>Both Compose extension modules provide the Children(...) function which has the following features:</p> <ul> <li>It listens for the <code>ChildStack</code> changes and displays the corresponding child <code>Composable</code> component using the provided slot lambda.</li> <li>It preserves components' UI state (e.g. scrolling position) in the back stack and over configuration changes and process death.</li> <li>It animates between children if there is an <code>animation</code> spec provided.</li> </ul> <p>Here is an example of switching child components on navigation:</p> <pre><code>// Root\n\ninterface RootComponent {\nval childStack: Value&lt;ChildStack&lt;*, Child&gt;&gt;\n\nsealed class Child {\ndata class MainChild(val component: MainComponent) : Child()\ndata class DetailsChild(val component: DetailsComponent) : Child()\n}\n}\n\n@Composable\nfun RootContent(rootComponent: RootComponent) {\nChildren(rootComponent.childStack) {\nwhen (val child = it.instance) {\nis MainChild -&gt; MainContent(child.component)\nis DetailsChild -&gt; DetailsContent(child.component)\n}\n}\n}\n\n// Children\n\ninterface MainComponent\n\ninterface DetailsComponent\n\n@Composable\nfun MainContent(component: MainComponent) {\n// Omitted code\n}\n\n@Composable\nfun DetailsContent(component: DetailsComponent) {\n// Omitted code\n}\n</code></pre>"},{"location":"extensions/compose/#pager-like-navigation","title":"Pager-like navigation","text":"<p>Warning</p> <p>This navigation model is experimental, the API is subject to change.</p> <p>The Child Pages navigation model provides ChildPages as <code>Value&lt;ChildPages&gt;</code> that can be observed in a <code>Composable</code> component.</p> <p>Both Compose extension modules provide the Pages(...) function which has the following features:</p> <ul> <li>It listens for the <code>ChildPages</code> changes and displays child components using <code>HorizontalPager</code> or <code>VerticalPager</code> (see the related Jetpack Compose documentation).</li> <li>It animates page changes if there is an <code>animation</code> spec provided.</li> </ul> Example<pre><code>@Composable\nfun PagesContent(component: PagesComponent) {\nPages(\npages = component.pages,\nonPageSelected = component::selectPage,\nscrollAnimation = PagesScrollAnimation.Default,\n) { _, page -&gt;\nPageContent(page)\n}\n}\n\n@Composable\nfun PageContent(component: PageComponent) {\n// Omitted code\n}\n</code></pre>"},{"location":"extensions/compose/#animations","title":"Animations","text":"<p>Decompose provides Child Animation API for Compose, as well as some predefined animation specs. To enable child animations you need to pass the <code>animation</code> argument to the <code>Children</code> function. There are predefined animators provided by Decompose.</p>"},{"location":"extensions/compose/#fade-animation","title":"Fade animation","text":"<pre><code>@Composable\nfun RootContent(component: RootComponent) {\nChildren(\nstack = component.childStack,\nanimation = stackAnimation(fade()),\n) {\n// Omitted code\n}\n}\n</code></pre>"},{"location":"extensions/compose/#slide-animation","title":"Slide animation","text":"<pre><code>@Composable\nfun RootContent(component: RootComponent) {\nChildren(\nstack = component.childStack,\nanimation = stackAnimation(slide()),\n) {\n// Omitted code\n}\n}\n</code></pre>"},{"location":"extensions/compose/#combining-animators","title":"Combining animators","text":"<p>It is also possible to combine animators using the <code>plus</code> operator. Please note that the order matters - the right animator is applied after the left animator.</p> <pre><code>@Composable\nfun RootContent(component: RootComponent) {\nChildren(\nstack = component.childStack,\nanimation = stackAnimation(fade() + scale())\n) {\n// Omitted code\n}\n}\n</code></pre> <p></p>"},{"location":"extensions/compose/#separate-animations-for-children","title":"Separate animations for children","text":"<p>Previous examples demonstrate simple cases, when all children have the same animation. But it is also possible to specify separate animations for children.</p> <pre><code>@Composable\nfun RootContent(component: RootComponent) {\nChildren(\nstack = component.childStack,\nanimation = stackAnimation { child -&gt;\nwhen (child.instance) {\nis MainChild -&gt; fade() + scale()\nis DetailsChild -&gt; fade() + slide()\n}\n}\n) {\n// Omitted code\n}\n}\n</code></pre> <p></p> <p>It is also possible to take into account the other child and the animation direction when selecting the animation.</p> <pre><code>@Composable\nfun RootContent(component: RootComponent) {\nChildren(\nstack = component.childStack,\nanimation = stackAnimation { child, otherChild, direction -&gt;\n// Select and return an animator here\n}\n) {\n// Omitted code\n}\n}\n</code></pre>"},{"location":"extensions/compose/#custom-animations","title":"Custom animations","text":"<p>It is also possible to define custom animations.</p>"},{"location":"extensions/compose/#implementing-stackanimation","title":"Implementing <code>StackAnimation</code>","text":"<p>This is the most flexible low-level API. The animation block receives the current <code>ChildStack</code> and animates children using the provided <code>content</code> slot.</p> <pre><code>@Composable\nfun RootContent(component: RootComponent) {\nChildren(\nstack = rootComponent.childStack,\nanimation = someAnimation(),\n) {\n// Omitted code\n}\n}\n\nfun &lt;C : Any, T : Any&gt; someAnimation(): StackAnimation&lt;C, T&gt; =\nStackAnimation { stack: ChildStack&lt;C, T&gt;,\nmodifier: Modifier,\ncontent: @Composable (Child.Created&lt;C, T&gt;) -&gt; Unit -&gt;\n// Render each frame here\n}\n</code></pre>"},{"location":"extensions/compose/#implementing-stackanimator","title":"Implementing <code>StackAnimator</code>","text":"<p>The <code>stackAnimation</code> function takes care of tracking the <code>ChildStack</code> changes. <code>StackAnimator</code> is only responsible for manipulating the <code>Modifier</code> in the given <code>direction</code>, and calling <code>onFinished</code> at the end.</p> <pre><code>@Composable\nfun RootContent(component: RootComponent) {\nChildren(\nstack = component.childStack,\nanimation = stackAnimation(someAnimator()),\n) {\n// Omitted code\n}\n}\n\nfun someAnimator(): StackAnimator =\nStackAnimator { direction: Direction,\nisInitial: Boolean,\nonFinished: () -&gt; Unit,\ncontent: @Composable (Modifier) -&gt; Unit -&gt;\n// Manipulate the Modifier in the given direction and call onFinished at the end\n}\n</code></pre>"},{"location":"extensions/compose/#using-stackanimator-function","title":"Using <code>stackAnimator</code> function","text":"<p>This is the simplest, but less powerful way. The <code>stackAnimator</code> function takes care of running the animation. Its block has a very limited responsibility - to render the current frame using the provided <code>factor</code> and <code>direction</code>.</p> <pre><code>@Composable\nfun RootContent(component: RootComponent) {\nChildren(\nstack = component.childStack,\nanimation = stackAnimation(someAnimator()),\n) {\n// Omitted code\n}\n}\n\nfun someAnimator(): StackAnimator =\nstackAnimator { factor: Float,\ndirection: Direction,\ncontent: (Modifier) -&gt; Unit -&gt;\n// Render the current frame\n}\n</code></pre> <p>Please refer to the predefined animators (<code>fade</code>, <code>slide</code>, etc.) for implementation examples.</p>"},{"location":"extensions/compose/#predictive-back-gesture","title":"Predictive Back Gesture","text":"<p>Warning</p> <p>Predictive Back Gesture support is experimental, the API is subject to change. For now, please use version 2.1.x.</p> <p><code>Child Stack</code> supports the new Android Predictive Back Gesture on all platforms. To enable the gesture, first implement <code>BackHandlerOwner</code> interface in your component with <code>Child Stack</code>, then just pass <code>predictiveBackAnimation</code> to the <code>Children</code> function.</p> RootComponent<pre><code>interface RootComponent : BackHandlerOwner {\nval stack: Value&lt;ChildStack&lt;...&gt;&gt;\n\nfun onBackClicked()\n}\n\nclass DefaultRootComponent(\ncomponentContext: ComponentContext,\n) : ComponentContext by componentContext, BackHandlerOwner {\n// ComponentContext already implements BackHandlerOwner, no need to implement it separately\n\n// Omitted body\n\noverride fun onBackClicked() {\nnavigation.pop()\n}\n}\n</code></pre> RootContent<pre><code>@Composable\nfun RootContent(component: RootComponent) {\nChildren(\nstack = rootComponent.childStack,\nanimation = predictiveBackAnimation(\nbackHandler = component.backHandler,\nanimation = stackAnimation(fade() + scale()), // Your usual animation here\nonBack = component::onBackClicked,\n),\n) {\n// Omitted code\n}\n}\n</code></pre>"},{"location":"extensions/compose/#predictive-back-gesture-on-android","title":"Predictive Back Gesture on Android","text":"<p>On Android, the predictive back gesture only works starting with Android T. On Android T, it works only between Activities, if enabled in the system settings. Starting with Android U, the predictive back gesture can be enabled between <code>Child Stack</code> screens inside a single Activity.</p>"},{"location":"extensions/compose/#predictive-back-gesture-on-other-platforms","title":"Predictive Back Gesture on other platforms","text":"<p>On all other platforms, the predictive back gesture can be enabled by showing a special overlay that automatically handles the gesture and manipulates <code>BackDispatcher</code> as needed.</p> Initialising the root component<pre><code>val lifecycle = LifecycleRegistry()\nval backDispatcher = BackDispatcher()\n\nval componentContext = DefaultComponentContext(\nlifecycle = lifecycle,\nbackHandler = backDispatcher, // Pass BackDispatcher here\n)\n\nval root = DefaultRootComponent(componentContext = componentContext)\n</code></pre> Using Composable PredictiveBackGestureOverlay<pre><code>PredictiveBackGestureOverlay(\nbackDispatcher = backDispatcher, // Use the same BackDispatcher as above\nbackIcon = { progress, _ -&gt;\nPredictiveBackGestureIcon(\nimageVector = Icons.Default.ArrowBack,\nprogress = progress,\n)\n},\nmodifier = Modifier.fillMaxSize(),\n) {\nRootContent(\ncomponent = root,\nmodifier = Modifier.fillMaxSize(),\n)\n}\n</code></pre>"},{"location":"extensions/compose/#predictive-back-gesture-on-ios","title":"Predictive Back Gesture on iOS","text":"<p>It is possible to customize the predictive back gesture, so it looks native-ish on iOS.</p> In commonMain source set<pre><code>@Composable\nfun RootContent(component: RootComponent) {\nChildren(\nstack = rootComponent.childStack,\nanimation = backAnimation(\nbackHandler = component.backHandler, onBack = component::onBackClicked,\n),\n) {\n// Omitted code\n}\n}\n\nexpect fun &lt;C : Any, T : Any&gt; backAnimation(\nbackHandler: BackHandler,\nonBack: () -&gt; Unit,\n): StackAnimation&lt;C, T&gt;\n</code></pre> In androidMain source set<pre><code>actual fun &lt;C : Any, T : Any&gt; backAnimation(\nbackHandler: BackHandler,\nonBack: () -&gt; Unit,\n): StackAnimation&lt;C, T&gt; =\npredictiveBackAnimation(\nbackHandler = backHandler,\nanimation = stackAnimation(fade() + scale()),\nonBack = onBack,\n)\n</code></pre> In iosMain source set<pre><code>actual fun &lt;C : Any, T : Any&gt; backAnimation(\nbackHandler: BackHandler,\nonBack: () -&gt; Unit,\n): StackAnimation&lt;C, T&gt; =\npredictiveBackAnimation(\nbackHandler = backHandler,\nanimation = stackAnimation(iosLikeSlide()),\nexitModifier = { progress, _ -&gt; Modifier.slideExitModifier(progress = progress) },\nenterModifier = { progress, _ -&gt; Modifier.slideEnterModifier(progress = progress) },\nonBack = onBack,\n)\n\nprivate fun iosLikeSlide(animationSpec: FiniteAnimationSpec&lt;Float&gt; = tween()): StackAnimator =\nstackAnimator(animationSpec = animationSpec) { factor, direction, content -&gt;\ncontent(\nModifier\n.then(if (direction.isFront) Modifier else Modifier.fade(factor + 1F))\n.offsetXFactor(factor = if (direction.isFront) factor else factor * 0.5F)\n)\n}\n\nprivate fun Modifier.slideExitModifier(progress: Float): Modifier =\noffsetXFactor(progress)\n\nprivate fun Modifier.slideEnterModifier(progress: Float): Modifier =\nfade(progress).offsetXFactor((progress - 1f) * 0.5f)\n\nprivate fun Modifier.fade(factor: Float) =\ndrawWithContent {\ndrawContent()\ndrawRect(color = Color(red = 0F, green = 0F, blue = 0F, alpha = (1F - factor) / 4F))\n}\n\nprivate fun Modifier.offsetXFactor(factor: Float): Modifier =\nlayout { measurable, constraints -&gt;\nval placeable = measurable.measure(constraints)\n\nlayout(placeable.width, placeable.height) {\nplaceable.placeRelative(x = (placeable.width.toFloat() * factor).toInt(), y = 0)\n}\n}\n</code></pre>"},{"location":"extensions/compose/#compose-for-ios-macos-and-web-canvas","title":"Compose for iOS, macOS and Web (Canvas)","text":"<p>Compose for iOS, macOS and Web (Canvas) is still work in progress and was not officially announced. However, Decompose already supports it. The support is also experimental and is not part of the main branch - see #74 for more information.</p> <p>If you want to use Decompose with Compose for iOS/macOS/Web, you have to use special versions of both <code>decompose</code> and <code>extensions-compose-jetbrains</code> modules.</p> GroovyKotlin <pre><code>implementation \"com.arkivanov.decompose:decompose:&lt;version&gt;-compose-experimental\"\nimplementation \"com.arkivanov.decompose:extensions-compose-jetbrains:&lt;version&gt;-compose-experimental\"\n</code></pre> <pre><code>implementation(\"com.arkivanov.decompose:decompose:&lt;version&gt;-compose-experimental\")\nimplementation(\"com.arkivanov.decompose:extensions-compose-jetbrains:&lt;version&gt;-compose-experimental\")\n</code></pre>"},{"location":"extensions/compose/#samples","title":"Samples","text":"<p>You can find samples in a separate branch - compose-darwin/sample/app-darwin-compose.</p>"},{"location":"extensions/overview/","title":"Extensions Overview","text":"<p>Decompose provides extension modules for various popular libraries and frameworks:</p> <ul> <li>Extensions for Jetpack/JetBrains Compose</li> <li>Extensions for Android views</li> </ul>"},{"location":"getting-started/contributing/","title":"Contributing","text":""},{"location":"getting-started/contributing/#documentation","title":"Documentation","text":"<p>All of the documentation is stored in the <code>docs/</code> folder of this repository and is all written in markdown. The documentation is generated with Material MkDocs, so if you want to see what the changes look like locally it is recommended to use Docker with the Material MkDocs docker image. </p> <pre><code># download the image\ndocker pull squidfunk/mkdocs-material\n\n# run the server locally \ndocker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material\n</code></pre> <p>Then add the new documentation markdown file into the appropriate folder inside <code>docs/</code> and add it to the <code>mkdocs.yml</code> file in the project so that it can be navigated to. Put up a pull request for review. </p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Decompose provides a number of modules, they are all published to Maven Central Repository.</p>"},{"location":"getting-started/installation/#the-main-decompose-module","title":"The main Decompose module","text":"<p>The main functionality is provided by the <code>decompose</code> module. It contains some core features like ComponentContext, Child Stack, etc.</p>"},{"location":"getting-started/installation/#gradle-setup","title":"Gradle setup","text":"GroovyKotlin <pre><code>implementation \"com.arkivanov.decompose:decompose:&lt;version&gt;\"\n</code></pre> <pre><code>implementation(\"com.arkivanov.decompose:decompose:&lt;version&gt;\")\n</code></pre>"},{"location":"getting-started/installation/#dependency-on-essenty-library","title":"Dependency on Essenty library","text":"<p>Some functionality is actually provided by Essenty library. Essenty is implemented by the same author and provides very basic things like <code>Lifecycle</code>, <code>StateKeeper</code>, etc. Most important Essenty modules are added to the <code>decompose</code> module as <code>api</code> dependency, so you don't have to add them manually to your project. Please familiarise yourself with Essenty library.</p> <p>Note</p> <p>If you are targetting Android, make sure you applied the kotlin-parcelize Gradle plugin.</p>"},{"location":"getting-started/installation/#extensions-for-jetpackjetbrains-compose","title":"Extensions for Jetpack/JetBrains Compose","text":"<p>The Compose UI is currently published in two separate variants:</p> <ul> <li>The one developed and maintained by Google is Android only, called Jetpack Compose</li> <li>The Kotlin Multiplatform variant of Jetpack Compose maintained by both JetBrains and Google, we call it JetBrains Compose</li> </ul> <p>Due to this fragmentation Decompose provides two separate extension modules for Compose UI:</p> <ul> <li><code>extensions-compose-jetpack</code> - Android library for Jetpack Compose</li> <li><code>extensions-compose-jetbrains</code> - Kotlin Multiplatform library for JetBrains Compose, supports <code>android</code> and <code>jvm</code> targets</li> </ul> <p>Both modules are used to connect Compose UI to Decompose components. Please see the corresponding documentation page.</p>"},{"location":"getting-started/installation/#gradle-setup_1","title":"Gradle setup","text":"<p>Typically only one module should be selected, depending on the Compose UI variant being used.</p> GroovyKotlin <pre><code>implementation \"com.arkivanov.decompose:extensions-compose-jetpack:&lt;version&gt;\"\n// or\nimplementation \"com.arkivanov.decompose:extensions-compose-jetbrains:&lt;version&gt;\"\n</code></pre> <pre><code>implementation(\"com.arkivanov.decompose:extensions-compose-jetpack:&lt;version&gt;\")\n// or\nimplementation(\"com.arkivanov.decompose:extensions-compose-jetbrains:&lt;version&gt;\")\n</code></pre>"},{"location":"getting-started/installation/#support-for-compose-for-ios-and-web-js-canvas-not-wasm","title":"Support for Compose for iOS and Web (JS Canvas, not WASM)","text":"<p>Compose for iOS and Web (JS Canvas, not WASM) are supported and published from a separate branch: <code>compose-experimental</code>. This means that a special version suffix for all Decompose modules is required when configuring dependencies.</p> GroovyKotlin <pre><code>implementation \"com.arkivanov.decompose:decompose:&lt;version&gt;-compose-experimental\"\nimplementation \"com.arkivanov.decompose:extensions-compose-jetbrains:&lt;version&gt;-compose-experimental\"\n</code></pre> <pre><code>implementation(\"com.arkivanov.decompose:decompose:&lt;version&gt;-compose-experimental\")\nimplementation(\"com.arkivanov.decompose:extensions-compose-jetbrains:&lt;version&gt;-compose-experimental\")\n</code></pre> <p>Warning</p> <p>WASM target is not yet supported. Please follow issue #74 for more information and updates.</p>"},{"location":"getting-started/installation/#extensions-for-android-views","title":"Extensions for Android views","text":"<p>The <code>extensions-android</code> module provides extensions to connect Android views based UI to Decompose components. Please head to the corresponding documentation page for more information.</p>"},{"location":"getting-started/installation/#gradle-setup_2","title":"Gradle setup","text":"GroovyKotlin <pre><code>implementation \"com.arkivanov.decompose:extensions-android:&lt;version&gt;\"\n</code></pre> <pre><code>implementation(\"com.arkivanov.decompose:extensions-android:&lt;version&gt;\")\n</code></pre>"},{"location":"getting-started/installation/#exporting-decompose-to-ios-framework","title":"Exporting Decompose to iOS Framework","text":"<p>For using Decompose on your iOS project you need to export it to the iOS Framework.</p>"},{"location":"getting-started/installation/#regular-framework","title":"Regular Framework","text":"<pre><code>...\nkotlin {\n...\ntargets\n.filterIsInstance&lt;KotlinNativeTarget&gt;()\n.filter { it.konanTarget.family == Family.IOS }\n.forEach {\nit.binaries.framework {\n...\n\nexport(\"com.arkivanov.decompose:decompose:&lt;version&gt;\")\nexport(\"com.arkivanov.essenty:lifecycle:&lt;essenty_version&gt;\")\n\n// Optional, only if you need state preservation on Darwin (Apple) targets\nexport(\"com.arkivanov.essenty:state-keeper:&lt;essenty_version&gt;\")\n\n// Optional, only if you need state preservation on Darwin (Apple) targets\nexport(\"com.arkivanov.parcelize.darwin:runtime:&lt;parcelize_darwin_version&gt;\")\n}\n}\n...\n}\n...\n</code></pre>"},{"location":"getting-started/installation/#cocoapods","title":"CocoaPods","text":"<pre><code>...\nkotlin {\n...\ncocoapods {\n...\nframework {\n...\n\nexport(\"com.arkivanov.decompose:decompose:&lt;version&gt;\")\nexport(\"com.arkivanov.essenty:lifecycle:&lt;essenty_version&gt;\")\n\n// Optional, only if you need state preservation on Darwin (Apple) targets\nexport(\"com.arkivanov.essenty:state-keeper:&lt;essenty_version&gt;\")\n\n// Optional, only if you need state preservation on Darwin (Apple) targets\nexport(\"com.arkivanov.parcelize.darwin:runtime:&lt;parcelize_darwin_version&gt;\")\n}\n}\n...\n}\n...\n</code></pre>"},{"location":"getting-started/license/","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>\u00a9 You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy] [name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"getting-started/quick-start/","title":"Quick start","text":"<p>Please see the template repository which can be used to kick-start your project.</p>"},{"location":"getting-started/quick-start/#a-simplest-component","title":"A simplest component","text":"<pre><code>class RootComponent\n</code></pre> <p>Yes, a simplest component is just a normal class. No need to extend a class from the library, or implement an interface.</p>"},{"location":"getting-started/quick-start/#extracting-an-interface","title":"Extracting an interface","text":"<pre><code>interface RootComponent\n\nclass DefaultRootComponent : RootComponent\n</code></pre> <p>It's often useful to extract an interface for a component. It makes it possible to create test doubles for integration tests (e.g. testing navigation in a container component), or fake implementations for UI previews (e.g. for Jetpack Compose or SwiftUI).</p>"},{"location":"getting-started/quick-start/#componentcontext","title":"ComponentContext","text":"<p>ComponentContext is probably the most important concept of Decompose. It is an interface that provides access to various tools, like lifecycle, state preservation, instance retaining (aka Android ViewModel), back button handling, etc. Each component has its own <code>ComponentContext</code> provided by Decompose.</p> <p>If your component requires <code>ComponentContext</code>, just pass it via constructor. You can also use the delegation pattern to add <code>ComponentContext</code> to <code>this</code> scope.</p> <pre><code>class DefaultRootComponent(\ncomponentContext: ComponentContext,\n) : RootComponent, ComponentContext by componentContext {\n\ninit {\nlifecycle... // Access the Lifecycle\nstateKeeper... // Access the StateKeeper\ninstanceKeeper... // Access the InstanceKeeper\nbackHandler... // Access the BackHandler\n}\n}\n</code></pre>"},{"location":"getting-started/quick-start/#observable-state-and-callbacks","title":"Observable state and callbacks","text":"<p>There are multiple ways of exposing an observable state from a component.</p>"},{"location":"getting-started/quick-start/#using-value-from-decompose","title":"Using Value from Decompose","text":"<p>Decompose provides an observable state holder - <code>Value</code>. It offers great integration with various UI frameworks, such as Jetpack Compose, SwiftUI, React, etc. You can also convert Reaktive <code>Observable</code> or coroutines <code>Flow</code> to <code>Value</code>, if needed.</p> <pre><code>interface ListComponent {\nval model: Value&lt;Model&gt;\n\nfun onItemClicked(item: String)\n\ndata class Model(\nval items: List&lt;String&gt;,\n)\n}\n\nclass DefaultListComponent(\ncomponentContext: ComponentContext,\nprivate val onItemSelected: (item: String) -&gt; Unit,\n) : ListComponent {\noverride val model: Value&lt;ListComponent.Model&gt; =\nMutableValue(Model(items = List(100) { \"Item $it\" }))\n\noverride fun onItemClicked(item: String) {\nonItemSelected(item)\n}\n}\n</code></pre>"},{"location":"getting-started/quick-start/#observing-value-in-jetpack-compose","title":"Observing Value in Jetpack Compose","text":"<p>Observing <code>Value</code> in Jetpack Compose is easy, just use the <code>subscribeAsState</code> extension function.</p> <pre><code>@Composable\nfun ListContent(component: ListComponent, modifier: Modifier = Modifier) {\nval model by component.model.subscribeAsState()\n\nLazyColumn {\nitems(items = model.items) { item -&gt;\nText(\ntext = item,\nmodifier = Modifier.clickable { component.onItemClicked(item = item) },\n)\n}\n}\n}\n</code></pre>"},{"location":"getting-started/quick-start/#observing-value-in-swiftui","title":"Observing Value in SwiftUI","text":"<pre><code>struct DetailsView: View {\n    private let list: ListComponent\n\n    @StateValue\n    private var model: ListComponentModel\n\n    init(_ list: ListComponent) {\n        self.list = list\n        _model = StateValue(list.model)\n    }\n\n    var body: some View {\n        List(model.items, ...) { item in\n            // Display the item\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#what-is-statevalue","title":"What is StateValue","text":"<p>StateValue is a property wrapper for <code>Value</code> that makes it observable in SwiftUI. Unfortunately it does not look possible to publish utils for SwiftUI as a library or framework, so it has to be copied in your project.</p>"},{"location":"getting-started/quick-start/#observing-value-in-other-ui-frameworks","title":"Observing Value in other UI Frameworks","text":"<p>Please refer to the docs for information about other platforms and UI frameworks.</p>"},{"location":"getting-started/quick-start/#using-reaktive-or-coroutines","title":"Using Reaktive or coroutines","text":"<p>The state can be also exposed using Reaktive <code>Observable</code> or coroutines <code>Flow</code>, or any other reactive library. Follow best practices recommended for the reactive library of your choice.</p>"},{"location":"getting-started/quick-start/#navigation","title":"Navigation","text":"<p>Decompose provides various ways to navigate, you can find more information in the docs. The most common navigation pattern is Child Stack.</p>"},{"location":"getting-started/quick-start/#component-configurations","title":"Component configurations","text":"<p>Child component configurations is another important concepts of Decompose. It allows supplying type safe arguments, as well as any kind of dependencies to child components.</p> <p>Each child component is represented by a persistent configuration class. A configuration class denotes which child component should be instantiated, and holds persistent arguments required for instantiation. A configuration class must be defined for every child component.</p>"},{"location":"getting-started/quick-start/#using-the-child-stack","title":"Using the Child Stack","text":"<pre><code>interface RootComponent {\n\nval stack: Value&lt;ChildStack&lt;*, Child&gt;&gt;\n\n// It's possible to pop multiple screens at a time on iOS\nfun onBackClicked(toIndex: Int)\n\n// Defines all possible child components\nsealed class Child {\nclass ListChild(val component: ListComponent) : Child()\nclass DetailsChild(val component: DetailsComponent) : Child()\n}\n}\n\nclass DefaultRootComponent(\ncomponentContext: ComponentContext,\n) : RootComponent, ComponentContext by componentContext {\n\nprivate val navigation = StackNavigation&lt;Config&gt;()\n\noverride val stack: Value&lt;ChildStack&lt;*, RootComponent.Child&gt;&gt; =\nchildStack(\nsource = navigation,\ninitialConfiguration = Config.List, // The initial child component is List\nhandleBackButton = true, // Automatically pop from the stack on back button presses\nchildFactory = ::child,\n)\n\nprivate fun child(config: Config, componentContext: ComponentContext): RootComponent.Child =\nwhen (config) {\nis Config.List -&gt; ListChild(listComponent(componentContext))\nis Config.Details -&gt; DetailsChild(detailsComponent(componentContext, config))\n}\n\nprivate fun listComponent(componentContext: ComponentContext): ListComponent =\nDefaultListComponent(\ncomponentContext = componentContext,\nonItemSelected = { item: String -&gt; // Supply dependencies and callbacks\nnavigation.push(Config.Details(item = item)) // Push the details component\n},\n)\n\nprivate fun detailsComponent(componentContext: ComponentContext, config: Config.Details): DetailsComponent =\nDefaultDetailsComponent(\ncomponentContext = componentContext,\nitem = config.item, // Supply arguments from the configuration\nonFinished = navigation::pop, // Pop the details component\n)\n\noverride fun onBackClicked(toIndex: Int) {\nnavigation.popTo(index = toIndex)\n}\n\n@Parcelize // The `kotlin-parcelize` plugin must be applied if you are targeting Android \nprivate sealed interface Config : Parcelable {\nobject List : Config\ndata class Details(val item: String) : Config\n}\n}\n</code></pre>"},{"location":"getting-started/quick-start/#child-stack-with-jetpack-compose","title":"Child Stack with Jetpack Compose","text":"<pre><code>@Composable\nfun RootContent(component: RootComponent, modifier: Modifier = Modifier) {\nChildren(\nstack = component.stack,\nmodifier = modifier,\nanimation = stackAnimation(fade() + scale()),\n) {\nwhen (val child = it.instance) {\nis ListChild -&gt; ListContent(component = child.component)\nis DetailsChild -&gt; DetailsContent(component = child.component)\n}\n}\n}\n</code></pre>"},{"location":"getting-started/quick-start/#child-stack-with-swiftui","title":"Child Stack with SwiftUI","text":"<pre><code>struct RootView: View {\n    private let root: RootComponent\n\n    init(_ root: RootComponent) {\n        self.root = root\n    }\n\n    var body: some View {\n        StackView(\n            stackValue: StateValue(root.stack),\n            getTitle: {\n                switch $0 {\n                case is RootComponentChild.ListChild: return \"List\"\n                case is RootComponentChild.DetailsChild: return \"Details\"\n                default: return \"\"\n                }\n            },\n            onBack: root.onBackClicked,\n            childContent: {\n                switch $0 {\n                case let child as RootComponentChild.ListChild: ListView(child.component)\n                case let child as RootComponentChild.DetailsChild: DetailsView(child.component)\n                default: EmptyView()\n                }\n            }\n        )\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#what-is-stackview","title":"What is StackView?","text":"<p>StackView is a view that displays <code>Child Stack</code> using the native SwiftUI navigation and providing the native UX. For the same reason, it has to be copied in your project.</p>"},{"location":"getting-started/quick-start/#child-stack-with-other-ui-frameworks","title":"Child Stack with other UI Frameworks","text":"<p>Please refer to samples for integrations with other UI frameworks.</p>"},{"location":"getting-started/quick-start/#initializing-a-root-component","title":"Initializing a root component","text":""},{"location":"getting-started/quick-start/#android-with-jetpack-compose","title":"Android with Jetpack Compose","text":"<p>Use <code>defaultComponentContext</code> extension function to create the root <code>ComponentContext</code> in an <code>Activity</code> or a <code>Fragment</code>.</p> <pre><code>class MainActivity : AppCompatActivity() {\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\n\n// Always create the root component outside Compose on the main thread\nval root =\nDefaultRootComponent(\ncomponentContext = defaultComponentContext(),\n)\n\nsetContent {\nMaterialTheme {\nSurface {\nRootContent(component = root, modifier = Modifier.fillMaxSize())\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"getting-started/quick-start/#desktop-with-jetpack-compose","title":"Desktop with Jetpack Compose","text":"<p>Use <code>LifecycleController</code> to bind the root lifecycle with the main window state. See an example of <code>runOnUiThread</code> function here - Utils.kt.</p> <pre><code>fun main() {\nval lifecycle = LifecycleRegistry()\n\n// Always create the root component outside Compose on the UI thread\nval root =\nrunOnUiThread {\nDefaultRootComponent(\ncomponentContext = DefaultComponentContext(lifecycle = lifecycle),\n)\n}\n\napplication {\nval windowState = rememberWindowState()\n\nLifecycleController(lifecycle, windowState)\n\nWindow(\nonCloseRequest = ::exitApplication,\nstate = windowState,\ntitle = \"My Application\"\n) {\nMaterialTheme {\nSurface {\nRootContent(component = root, modifier = Modifier.fillMaxSize())\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"getting-started/quick-start/#ios-with-swiftui","title":"IOS with SwiftUI","text":"<ol> <li>Create <code>RootHolder</code> class that holds the root component and its lifecycle.</li> </ol> <pre><code>class RootHolder : ObservableObject {\n    let lifecycle: LifecycleRegistry\n    let root: RootComponent\n\n    init() {\n        lifecycle = LifecycleRegistryKt.LifecycleRegistry()\n\n        root = DefaultRootComponent(\n            componentContext: DefaultComponentContext(lifecycle: lifecycle)\n        )\n\n        LifecycleRegistryExtKt.create(lifecycle)\n    }\n\n    deinit {\n        // Destroy the root component before it is deallocated\n        LifecycleRegistryExtKt.destroy(lifecycle)\n    }\n}\n</code></pre> <ol> <li>Declare a simple <code>AppDelegate</code> containing <code>RootHolder</code></li> </ol> <pre><code>class AppDelegate: NSObject, UIApplicationDelegate {\n    let rootHolder: RootHolder = RootHolder()\n}\n</code></pre> <ol> <li>Create <code>RootHolder</code> instance and pass it to <code>RootView</code>.</li> </ol> <pre><code>@main\nstruct app_iosApp: App {\n    @UIApplicationDelegateAdaptor(AppDelegate.self)\n    var appDelegate: AppDelegate\n\n    @Environment(\\.scenePhase)\n    var scenePhase: ScenePhase\n\n    var rootHolder: RootHolder { appDelegate.rootHolder }\n\n    var body: some Scene {\n        WindowGroup {\n            RootView(rootHolder.root)\n                .onChange(of: scenePhase) { newPhase in\n                    switch newPhase {\n                    case .background: LifecycleRegistryExtKt.stop(rootHolder.lifecycle)\n                    case .inactive: LifecycleRegistryExtKt.pause(rootHolder.lifecycle)\n                    case .active: LifecycleRegistryExtKt.resume(rootHolder.lifecycle)\n                    @unknown default: break\n                    }\n                }\n        }\n    }\n}\n</code></pre>"},{"location":"getting-started/quick-start/#javascript-web","title":"JavaScript (Web)","text":"<p>In the place where you create your <code>RootComponent</code>:</p> <ol> <li>Initialize a <code>LifecycleRegistry</code>.</li> <li>Pass it into the root <code>ComponentContext</code>.</li> <li>Attach the <code>LifecycleRegistry</code> to the <code>document</code> via an extension function.</li> </ol> <pre><code>@OptIn(ExperimentalDecomposeApi::class)\nfun main() {\n// Initialize a `LifecycleRegistry`\nval lifecycle = LifecycleRegistry()\n\nval root =\nRootComponent(\n// Pass the LifecycleRegistry to the context\ncomponentContext = DefaultComponentContext(lifecycle = lifecycle),\n... // Other dependencies here\n)\n\n// Attach the LifecycleRegistry to document\nlifecycle.attachToDocument()\n\n// Render the UI\ncreateRoot(document.getElementById(\"app\")!!).render(\nRootContent.create {\ncomponent = root\n}\n)\n}\n\n// Attaches the LifecycleRegistry to the document\nprivate fun LifecycleRegistry.attachToDocument() {\nfun onVisibilityChanged() {\nif (document.visibilityState == \"visible\") {\nresume()\n} else {\nstop()\n}\n}\n\nonVisibilityChanged()\n\ndocument.addEventListener(type = \"visibilitychange\", callback = { onVisibilityChanged() })\n}\n\nprivate val Document.visibilityState: String\nget() = asDynamic().visibilityState.unsafeCast&lt;String&gt;()\n</code></pre>"},{"location":"getting-started/quick-start/#other-platforms-and-ui-frameworks","title":"Other platforms and UI frameworks","text":"<p>Please refer to samples for integrations with other platforms and UI frameworks. </p>"},{"location":"navigation/overview/","title":"Navigation overview","text":"<p>Decompose provides the ability to create permanent child components using the <code>childStack</code> extension function. But if you need to dynamically switch child components, then navigation comes in handy.</p> <p>Currently, Decompose provides two predefined navigation models:</p> <ul> <li>Child Stack - prefer this way if you need to organize child components in a stack and navigate between them.</li> <li>Child Slot - prefer this way if you need to activate-dismiss one child component at a time.</li> <li>Child Pages - prefer this way if you need to organize child components in a list with one selected component.</li> </ul> <p>If none of this fit your needs, Decompose introduces Generic Navigation that can be used to create your own custom navigation models. It offers a flexible API and allows you to create almost any kind of navigation.</p> <p>It is possible to have more than one navigation model in a parent component. Make sure that you supplied different keys (the <code>key</code> argument) if you have two or more navigation models of the same kind (e.g. you have two <code>Child Stacks</code> in one parent component).</p>"},{"location":"navigation/overview/#component-configurations-and-child-factories","title":"Component configurations and child factories","text":"<p>The term <code>Configuration</code> is widely used in Decompose navigation. A configuration is a persistent class that represents a child component and contains all its arguments (not dependencies). Decompose automatically persists child configurations using StateKeeper, so child components are automatically recreated on events like Android configuration changes, process death, etc.</p> <p>Usually, you initialize a navigation by supplying a child factory function to Decompose. The function accepts a child configuration and <code>ComponentContext</code> and returns a new instance of the corresponding child component - <code>(Config, ComponentContext) -&gt; Child</code>. When you need to navigate, you call a navigation method and pass a configuration there. Decompose automatically creates and manages a ComponentContext for every child component, and calls the provided factory function when a new instance of a child component is required. This is where you should instantiate child components and supply dependencies, the configuration only provides persistent arguments and is used to distinguish which component to create. </p>"},{"location":"navigation/overview/#configuration-requirements","title":"Configuration requirements","text":"<p>Configurations must meet the following requirements:</p> <ol> <li>Be immutable</li> <li>Correctly implement <code>equals()</code> and <code>hashCode()</code> methods</li> <li>Implement <code>Parcelable</code> interface</li> </ol> <p>Different kinds of navigation may have additional requirements for configurations. It's recommended to define configurations as <code>data class</code>, and use only <code>val</code> properties and immutable data structures.</p>"},{"location":"navigation/overview/#configurations-are-parcelable","title":"Configurations are Parcelable","text":"<p><code>Configurations</code> can be persisted via Android's saved state, thus allowing the navigation state to be restored after configuration changes or process death.</p> <p>Decompose uses Essenty library, which provides both <code>Parcelable</code> interface and <code>@Parcelize</code> annotation in common code using expect/actual, which works well with Kotlin Multiplatform. Please familiarise yourself with Essenty library.</p>"},{"location":"navigation/overview/#android-target","title":"Android target","text":"<p>If you support the <code>android</code> target, make sure you have applied kotlin-parcelize Gradle plugin. Otherwise, your code won't compile for Android.</p> <p>Warning</p> <p>On Android the amount of data that can be preserved is limited. Please mind the size of configurations.</p>"},{"location":"navigation/overview/#navigation-and-the-main-thread","title":"Navigation and the main thread","text":"<p>The navigation API is thread-safe, technically the navigation can be performed on any thread. However, it's strongly recommended to perform the navigation on the Main thread. Since the navigation is performed synchronously, Decompose instantiates components and calls lifecycle callbacks on the current thread. Navigating on a background thread may cause unexpected behaviour.</p> <p>Warning</p> <p>Always perform the navigation on the Main thread.</p> <p>Decompose tries its best to detect when the navigation is performed on a non-main thread. When it happens, Decompose calls the special error handler - <code>onDecomposeError</code>. By default, it prints the exception to logs,  however you can override the default behaviour by providing your own handler.</p>"},{"location":"navigation/children/overview/","title":"Generic Navigation","text":"<p>The <code>Generic Navigation</code> can be used to create custom navigation models, when none of the predefined models fit your needs. It offers a flexible API and allows you to create almost any kind of navigation. Please check out Child Stack and Child Slot before using the <code>Generic Navigation</code>.</p> <p>The API is based around NavState and ChildNavState interfaces that should be implemented by clients. <code>NavState</code> represents a persistent state of the navigation. It also holds a navigation state for each child - <code>ChildNavState</code>. Both <code>NavState</code> and <code>ChildNavState</code> must be immutable, and correctly implement <code>equals</code> and <code>hashCode</code> methods (or just be data classes). There must be no duplicated (by equality) <code>ChildNavState.configuration</code> within a <code>NavState</code>.</p> <p>The navigation is performed by transforming the current <code>NavState</code> to a new one. The <code>Generic Navigation</code> implementation calculates diffs between the old list of <code>ChildNavState</code> and the new one, and manipulates child components as needed.</p>"},{"location":"navigation/children/overview/#childnavstate","title":"ChildNavState","text":"<p><code>ChildNavState</code> represents a state of a child component. It holds a <code>Configuration</code> that works as a key of the child component, and a <code>Status</code> that represents the required lifecycle status of the child component. As mentioned earlier, the <code>Configuration</code> must unique within the <code>NavState</code>.</p> <p>The <code>Status</code> can be one of the following:</p> <ul> <li> <p><code>ACTIVE</code> - the child component is instantiated and active. Its maximum lifecycle state is <code>RESUMED</code>, depending on the parent's lifecycle state. An active component can handle back button presses. The state of the component is saved when it switches from <code>ACTIVE</code> to any other status.</p> </li> <li> <p><code>INACTIVE</code> - the child component is instantiated and inactive. Its maximum lifecycle state is <code>CREATED</code>, depending on the parent's lifecycle state. An inactive component cannot handle back button presses.</p> </li> <li> <p><code>DESTROYED</code> - the child component is destroyed but still managed, e.g. it's state may be saved and restored later.</p> </li> </ul> <p>If you want to completely remove the child component from the navigation, you should remove its <code>ChildNavState</code> from the <code>NavState</code> altogether.</p> <p>The SimpleChildNavState class implements the <code>ChildNavState</code> interfaces. It can be used in simple cases when custom implementation is not required.</p>"},{"location":"navigation/children/overview/#using-the-generic-navigation","title":"Using the Generic Navigation","text":"<p>Using the <code>Generic Navigation</code> is pretty similar to any other navigation model, there is ComponentContext.children(...) extension function.</p> <pre><code>fun &lt;C : Any, T : Any, E : Any, N : NavState&lt;C&gt;, S : Any&gt; ComponentContext.children(\nsource: NavigationSource&lt;E&gt;,\nkey: String,\ninitialState: () -&gt; N,\nsaveState: (state: N) -&gt; ParcelableContainer?,\nrestoreState: (container: ParcelableContainer) -&gt; N?,\nnavTransformer: (state: N, event: E) -&gt; N,\nstateMapper: (state: N, children: List&lt;Child&lt;C, T&gt;&gt;) -&gt; S,\nonStateChanged: (newState: N, oldState: N?) -&gt; Unit = { _, _ -&gt; },\nonEventComplete: (event: E, newState: N, oldState: N) -&gt; Unit = { _, _, _ -&gt; },\nbackTransformer: (state: N) -&gt; (() -&gt; N)? = { null },\nchildFactory: (configuration: C, componentContext: ComponentContext) -&gt; T,\n): Value&lt;S&gt;\n</code></pre> <p>The <code>children</code> function has the following type parameters:</p> <ul> <li><code>C</code> - a type of component configurations.</li> <li><code>T</code> - a type of components.</li> <li><code>E</code> - a type of navigation events.</li> <li><code>N</code> - a type of navigation state, must implement <code>NavState</code> interface.</li> <li><code>S</code> - a type of the resulting children state.</li> </ul> <p>The <code>children</code> function accepts the following arguments:</p> <ul> <li><code>source: NavigationSource&lt;E&gt;</code> - an observable source of navigation events, the <code>Generic Navigation</code> subscribes to the source and performs the navigation. The SimpleNavigation class can be used in simple cases when custom implementation is not required.</li> <li><code>key: String</code> - a key of the navigation, must be unique if there are multiple <code>children</code> used in the same component.</li> <li><code>initialState: () -&gt; N</code> - an initial navigation state that should be used if there is no previously saved state.</li> <li><code>saveState: (state: N) -&gt; ParcelableContainer</code> - a function that saves the provided navigation state into <code>ParcelableContainer</code>, called when the hosting component goes to background.</li> <li><code>restoreState: (container: ParcelableContainer) -&gt; N</code> - a function that restores the navigation state from the provided <code>ParcelableContainer</code>. The restored navigation state must have the same amount of child configurations and in the same order. The restored child <code>Statuses</code> can be any, e.g. a previously active child may become destroyed, etc.</li> <li><code>navTransformer: (state: N, event: E) -&gt; N</code> - a function that transforms the current navigation state to a new one using the provided navigation event. The implementation diffs both navigation states and manipulates child components as needed.</li> <li><code>stateMapper: (state: N, children: List&lt;Child&lt;C, T&gt;&gt;) -&gt; S</code> - combines the provided navigation state and list of child components to a resulting custom state.</li> <li><code>onStateChanged: (newState: N, oldState: N?) -&gt; Unit</code> - called every time the navigation state changes, <code>oldState</code> is <code>null</code> when called first time during initialisation. </li> <li><code>onEventComplete: (event: E, newState: N, oldState: N) -&gt; Unit</code> - called when a navigation event is processed and the navigation completed.</li> <li><code>backTransformer: (state: N) -&gt; (() -&gt; N)?</code> - a function that checks the provided navigation state, and either returns another function transforming the navigation state to a new one, or <code>null</code> if back button handling should be disabled. Called during the initialisation and after each navigation event.</li> <li><code>childFactory: (configuration: C, componentContext: ComponentContext) -&gt; T</code> - childFactory a factory function that creates new child component instances.</li> </ul> <p>The <code>children</code> function returns an observable <code>Value</code> of the resulting children state.</p>"},{"location":"navigation/children/overview/#examples","title":"Examples","text":"<p>All existing navigation models (like Child Stack) are implemented using the <code>Generic Navigation</code>. Please refer to their source code for implementation details.</p>"},{"location":"navigation/children/overview/#sample-project","title":"Sample project","text":"<p>See the sample project has the CustomNavigationComponent, which demonstrates how to use the <code>Generic Navigation</code>.</p> <p></p>"},{"location":"navigation/pages/navigation/","title":"Navigation with Child Pages","text":""},{"location":"navigation/pages/navigation/#the-pagesnavigator","title":"The PagesNavigator","text":"<p>All navigation in <code>Child Pages</code> is performed using the <code>PagesNavigator</code> interface, which is extended by the <code>PagesNavigation</code> interface.</p> <p><code>PagesNavigator</code> contains the <code>navigate</code> method with the following arguments:</p> <ul> <li><code>transformer</code> - converts the current navigation state (<code>Pages</code>) into a new one.</li> <li><code>onComplete</code> - called when navigation is finished.</li> </ul> <p>There is also <code>navigate</code> extension function without the <code>onComplete</code> callback, for convenience.</p> Creating the navigation<pre><code>val navigation = PagesNavigation&lt;Configuration&gt;()\n</code></pre>"},{"location":"navigation/pages/navigation/#the-navigation-process","title":"The navigation process","text":"<p>During the navigation process, the Child Pages navigation model compares the new [Pages] state with the previous one. The navigation model ensures that all removed components are destroyed, and updates lifecycles of the existing components to match the new state.</p> <p>The navigation is usually performed synchronously, which means that by the time the <code>navigate</code> method returns, the navigation is finished and all component lifecycles are moved into required states. However, the navigation is performed asynchronously in case of recursive invocations - e.g. <code>selectNext</code> is called from <code>onResume</code> lifecycle callback of a component being shown. All recursive invocations are queued and performed one by one once the current navigation is finished.</p>"},{"location":"navigation/pages/navigation/#pagesnavigator-extension-functions","title":"PagesNavigator extension functions","text":"<p>There are <code>PagesNavigator</code> extension functions to simplify the navigation. Some of which were already used in the Child Pages overview example.</p>"},{"location":"navigation/pages/navigation/#selectnext","title":"selectNext","text":"<p>Selects the next component. If the currently selected component is the last one, then depending on the [circular] parameter, either nothing happens or the first component is selected.</p> Before<pre><code>1: [A, B*, C]\n2: [A, B, C*]\n3: [A, B, C*]\n</code></pre> <pre><code>1: navigation.selectNext()\n2: navigation.selectNext(circular = false)\n3: navigation.selectNext(circular = true)\n</code></pre> After<pre><code>1: [A, B, C*]\n2: [A, B, C*]\n3: [A*, B, C]\n</code></pre>"},{"location":"navigation/pages/navigation/#selectprev","title":"selectPrev","text":"<p>elects the previous component. If the currently selected component is the first one, then depending on the [circular] parameter, either nothing happens or the last component is selected.</p> Before<pre><code>1: [A, B*, C]\n2: [A*, B, C]\n3: [A*, B, C]\n</code></pre> <pre><code>1: navigation.selectPrev()\n2: navigation.selectPrev(circular = false)\n3: navigation.selectPrev(circular = true)\n</code></pre> After<pre><code>1: [A*, B, C]\n2: [A*, B, C]\n3: [A, B, C*]\n</code></pre>"},{"location":"navigation/pages/navigation/#selectfirst","title":"selectFirst","text":"<p>Selects the first component.</p> Before<pre><code>[A, B*, C]\n</code></pre> <pre><code>navigation.selectFirst()\n</code></pre> After<pre><code>[A*, B, C]\n</code></pre>"},{"location":"navigation/pages/navigation/#selectlast","title":"selectLast","text":"<p>Selects the last component.</p> Before<pre><code>[A, B*, C]\n</code></pre> <pre><code>navigation.selectLast()\n</code></pre> After<pre><code>[A, B, C*]\n</code></pre>"},{"location":"navigation/pages/navigation/#selectindex","title":"select(index)","text":"<p>Selects the component at the specified [index]. Throws [IllegalArgumentException] if the index is out of bounds.</p> Before<pre><code>[A*, B, C]\n</code></pre> <pre><code>navigation.select(2)\n</code></pre> After<pre><code>[A, B, C*]\n</code></pre>"},{"location":"navigation/pages/navigation/#clear","title":"clear","text":"<p>Clears the current [Pages] state, i.e. removes all components.</p> Before<pre><code>[A, B*, C]\n</code></pre> <pre><code>navigation.clear()\n</code></pre> After<pre><code>[]\n</code></pre>"},{"location":"navigation/pages/overview/","title":"Child Pages overview","text":""},{"location":"navigation/pages/overview/#the-child-pages-experimental","title":"The Child Pages (experimental)","text":"<p><code>Child Pages</code> is a navigation model for managing a list of components (pages) with one selected (active) component. The list can be empty.</p> <p>Warning</p> <p>This navigation model is experimental, the API is subject to change.</p> <p>Similarly to <code>Child Stack</code>, each component has its own <code>Lifecycle</code>. By default, the currently selected page is <code>ACTIVE</code>, its two neighbours are <code>INACTIVE</code>, and the rest are <code>DESTROYED</code>. You can implement your own logic, for example with circular behaviour. </p> <p>It is possible to have more than one <code>Child Pages</code> navigation model in a component, nested navigation is also supported.</p> <p>The <code>Child Pages</code> navigation model consists of two main entities:</p> <ul> <li>Pages - represents a state of the <code>Child Pages</code> navigation model. The navigation is performed by creating a new navigation state from the previous one.<ul> <li><code>Pages#items</code> - the list of child configurations, must be unique, can be empty.</li> <li><code>Pages#selectedIndex</code> - index of the selected child configuration.</li> </ul> </li> <li>ChildPages - a simple data class that stores a list of components and their configurations, as well as the currently selected index.<ul> <li><code>ChildPages#items</code> - the list of child component, can be empty.</li> <li><code>ChildPages#selectedIndex</code> - the index of the currently selected child component. Must be within the range of <code>items</code> indices if <code>items</code> is not empty, otherwise can be any number.</li> </ul> </li> <li>PagesNavigation - an interface that accepts navigation commands and forwards them to all subscribed observers.</li> </ul>"},{"location":"navigation/pages/overview/#component-configurations","title":"Component Configurations","text":"<p>Similarly to <code>Child Stack</code>, each component created and managed by the <code>Child Pages</code> has a configuration, please read the documentation about child configurations.</p> <p><code>Child Pages</code> adds one additional requirement for child configurations:</p> <ul> <li>Configurations must be unique (by equality) within <code>Child Pages</code>.</li> </ul>"},{"location":"navigation/pages/overview/#initializing-child-pages","title":"Initializing Child Pages","text":"<p>There are three steps to initialize <code>Child Pages</code>:</p> <ul> <li>Create a new instance of <code>PagesNavigation</code> and assign it to a variable or a property.</li> <li>Initialize the <code>Child Pages</code> navigation model using the <code>ComponentContext#childPages</code> extension function and pass <code>PagesNavigation</code> into it along with other arguments.</li> <li>The <code>childPages</code> function returns <code>Value&lt;ChildPages&gt;</code> that can be observed in the UI. Assign the returned <code>Value</code> to another property or a variable.</li> </ul>"},{"location":"navigation/pages/overview/#example","title":"Example","text":"<p>Here is a very basic example of a pager-like navigation:</p> PageComponent<pre><code>interface PageComponent {\nval data: String\n}\n\nclass DefaultPageComponent(\ncomponentContext: ComponentContext,\noverride val data: String,\n) : PageComponent, ComponentContext by componentContext\n</code></pre> PagesComponent<pre><code>interface PagesComponent {\nval pages: Value&lt;ChildPages&lt;*, PageComponent&gt;&gt;\n\nfun selectPage(index: Int)\n}\n\nclass DefaultPagesComponent(\ncomponentContext: ComponentContext,\n) : PagesComponent, ComponentContext by componentContext {\n\nprivate val navigation = PagesNavigation&lt;Config&gt;()\n\noverride val pages: Value&lt;ChildPages&lt;*, PageComponent&gt;&gt; =\nchildPages(\nsource = navigation,\ninitialPages = {\nPages(\nitems = List(10) { index -&gt; Config(data = \"Item $index\") },\nselectedIndex = 0,\n)\n},\n) { config, childComponentContext -&gt;\nDefaultPageComponent(\ncomponentContext = childComponentContext,\ndata = config.data,\n)\n}\n\noverride fun selectPage(index: Int) {\nnavigation.select(index = index)\n}\n\n@Parcelize\nprivate data class Config(val data: String) : Parcelable\n}\n</code></pre>"},{"location":"navigation/pages/overview/#screen-recreation-and-process-death-on-not-only-android","title":"Screen recreation and process death on (not only) Android","text":"<p><code>Child Pages</code> automatically preserves the state when a configuration change or process death occurs. Use the <code>persistent</code> argument to disable state preservation completely. When disabled, the state is reset to the initial state when recreated.</p> <p>Components are created in their order. E.g. the first component in the list is created first, then the next component in the list is created, and so on. Components are destroyed in reverse order.</p>"},{"location":"navigation/pages/overview/#multiple-child-pages-in-a-component","title":"Multiple Child Pages in a component","text":"<p>When multiple <code>Child Pages</code> are used in one component, each such <code>Child Pages</code> must have a unique <code>key</code> argument associated. The keys are required to be unique only within the hosting component, so it is ok for different components to have <code>Child Pages</code> with same keys. An exception will be thrown if multiple <code>Child Pages</code> with the same key are detected in a component.</p>"},{"location":"navigation/slot/component-context/","title":"Child Slot with custom <code>ComponentContext</code>","text":"<p>Custom <code>ComponentContext</code> allows passing extra data and functionality to every child component. See Custom ComponentContext page for more information about creating custom <code>AppComponentContext</code>.</p> <p>In order to pass custom component context (like <code>AppComponentContext</code>) to child slot components, make an extension function on your <code>AppComponentContext</code> interface. This custom extension function will initialize the <code>Child Slot</code> and provide every child an <code>AppComponentContext</code>.</p> <pre><code>inline fun &lt;reified C : Parcelable, T : Any&gt; AppComponentContext.appChildSlot(\nsource: SlotNavigationSource&lt;C&gt;,\nnoinline initialConfiguration: () -&gt; C? = { null },\nkey: String = \"DefaultSlot\",\nhandleBackButton: Boolean = false,\npersistent: Boolean = false,\nnoinline childFactory: (configuration: C, AppComponentContext) -&gt; T\n): Value&lt;ChildSlot&lt;C, T&gt;&gt; =\nchildSlot(\nsource = source,\nkey = key,\nhandleBackButton = handleBackButton,\ninitialConfiguration = initialConfiguration,\npersistent = persistent\n) { configuration, componentContext -&gt;\nchildFactory(\nconfiguration,\nDefaultAppComponentContext(\ncomponentContext = componentContext,\n// Additional dependencies here\n)\n)\n}\n</code></pre> <p>Finally, in your components you can use the new extension function that will utilize the custom <code>AppComponentContext</code>.</p> <pre><code>interface RootComponent {\nval dialog: Value&lt;ChildSlot&lt;*, DialogComponent&gt;&gt;\n}\n\nclass DefaultRootComponent(\ncomponentContext: AppComponentContext,\n) : RootComponent, AppComponentContext by componentContext {\n\nprivate val dialogNavigation = SlotNavigation&lt;DialogConfig&gt;()\n\noverride val dialog: Value&lt;ChildSlot&lt;*, DialogComponent&gt;&gt; =\nappChildSlot(\nsource = dialogNavigation,\n// persistent = false, // Disable navigation state saving, if needed\nhandleBackButton = true, // Close the dialog on back button press\n) { config, childComponentContext -&gt;\nDefaultDialogComponent(\ncomponentContext = childComponentContext,\nmessage = config.message,\nonDismissed = dialogNavigation::dismiss,\n)\n}\n\nprivate fun showDialog(message: String) {\ndialogNavigation.activate(DialogConfig(message = message))\n}\n\n@Parcelize\nprivate data class DialogConfig(val message: String) : Parcelable\n}\n</code></pre>"},{"location":"navigation/slot/navigation/","title":"Navigation with Child Slot","text":""},{"location":"navigation/slot/navigation/#the-slotnavigator","title":"The SlotNavigator","text":"<p>All navigation in <code>Child Slot</code> is performed using the <code>SlotNavigator</code> interface, which is extended by the <code>SlotNavigation</code> interface. </p> <p><code>SlotNavigator</code> contains the <code>navigate</code> method with the following arguments:</p> <ul> <li><code>transformer</code> - converts the current configuration (if any) into a new one or <code>null</code>.</li> <li><code>onComplete</code> - called when navigation is finished.</li> </ul> <p>There is also <code>navigate</code> extension function without the <code>onComplete</code> callback, for convenience.</p> Creating the navigation<pre><code>val navigation = SlotNavigation&lt;DialogConfig&gt;()\n</code></pre>"},{"location":"navigation/slot/navigation/#the-navigation-process","title":"The navigation process","text":"<p>During the navigation process, <code>Child Slot</code> compares the new configuration with the previous one. If both are the same, then no navigation is performed. Otherwise, the currently active component is destroyed (if any), and a new one is activated (if the new configuration is not <code>null</code>).  </p> <p><code>Child Slot</code> usually performs the navigation synchronously, which means that by the time the <code>navigate</code> method returns, the navigation is finished and all component lifecycles are moved into required states. However, the navigation is performed asynchronously in case of recursive invocations - e.g. <code>dismiss</code> is called from <code>onResume</code> lifecycle callback of a component being activated. All recursive invocations are queued and performed one by one once the current navigation is finished.</p>"},{"location":"navigation/slot/navigation/#slotnavigator-extension-functions","title":"SlotNavigator extension functions","text":"<p>There are <code>SlotNavigator</code> extension functions to simplify the navigation.</p>"},{"location":"navigation/slot/navigation/#activate","title":"activate","text":"<p>Activates a component with the provided <code>Configuration</code> (if not <code>null</code>). Any currently active component is destroyed.</p> <pre><code>navigation.activate(DialogConfig(title = \"Some title\"))\n</code></pre>"},{"location":"navigation/slot/navigation/#dismiss","title":"dismiss","text":"<p>Destroys the currently active component, if any.</p> <pre><code>navigation.dismiss()\n</code></pre>"},{"location":"navigation/slot/overview/","title":"Child Slot overview","text":""},{"location":"navigation/slot/overview/#the-child-slot","title":"The Child Slot","text":"<p><code>Child Slot</code> is a navigation model that allows only one child component at a time, or none. In other words, each <code>Child Slot</code> allows to activate a child component, replace with another child component, or dismiss when not needed. It is possible to have more than one <code>Child Slot</code> in a component, nested slots are also supported.</p> <p>The most common use cases include but not limited to displaying dialogs, drawers, bottom sheets, and just changing the visibility of some views. It's not necessarily something that overlays the parent component.</p> <p>The <code>Child Slot</code> navigation consists of two main entities:</p> <ul> <li>ChildSlot - a simple data class that holds the currently active child, if any.</li> <li>SlotNavigation - an interface that accepts navigation commands and forwards them to all subscribed observers.</li> </ul>"},{"location":"navigation/slot/overview/#component-configurations","title":"Component Configurations","text":"<p>Each component created and managed by the <code>Child Slot</code> has a configuration, please read the documentation about child configurations. </p>"},{"location":"navigation/slot/overview/#initializing-the-child-slot","title":"Initializing the Child Slot","text":"<p>There are three steps to initialize the <code>Child Slot</code>:</p> <ul> <li>Create a new instance of <code>SlotNavigation</code> and assign it to a variable or a property.</li> <li>Initialize the <code>Child Slot</code> using the <code>ComponentContext#childSlot</code> extension function and pass <code>SlotNavigation</code> into it along with other arguments.</li> <li>The <code>childSlot</code> function returns <code>Value&lt;ChildSlot&gt;</code> that can be observed in the UI. Assign the returned <code>Value</code> to another property or a variable.</li> </ul>"},{"location":"navigation/slot/overview/#example","title":"Example","text":"<p>Here is a very basic example of a child slot:</p> Dialog component<pre><code>interface DialogComponent {\n\nfun onDismissClicked()\n}\n\nclass DefaultDialogComponent(\nprivate val componentContext: ComponentContext,\nprivate val message: String,\nprivate val onDismissed: () -&gt; Unit,\n) : DialogComponent, ComponentContext by componentContext {\n\noverride fun onDismissClicked() {\nonDismissed()\n}\n}\n</code></pre> Root component<pre><code>interface RootComponent {\n\nval dialog: Value&lt;ChildSlot&lt;*, DialogComponent&gt;&gt;\n}\n\nclass DefaultRootComponent(\ncomponentContext: ComponentContext,\n) : RootComponent, ComponentContext by componentContext {\n\nprivate val dialogNavigation = SlotNavigation&lt;DialogConfig&gt;()\n\noverride val dialog: Value&lt;ChildSlot&lt;*, DialogComponent&gt;&gt; =\nchildSlot(\nsource = dialogNavigation,\n// persistent = false, // Disable navigation state saving, if needed\nhandleBackButton = true, // Close the dialog on back button press\n) { config, childComponentContext -&gt;\nDefaultDialogComponent(\ncomponentContext = childComponentContext,\nmessage = config.message,\nonDismissed = dialogNavigation::dismiss,\n)\n}\n\nprivate fun showDialog(message: String) {\ndialogNavigation.activate(DialogConfig(message = message))\n}\n\n@Parcelize\nprivate data class DialogConfig(\nval message: String,\n) : Parcelable\n}\n</code></pre>"},{"location":"navigation/slot/overview/#multiple-child-slots-in-a-component","title":"Multiple Child Slots in a component","text":"<p>When multiple <code>Child Slots</code> are used in one component, each such <code>Child Slot</code> must have a unique key associated. The keys are required to be unique only within the parent (hosting) component, so it is ok for different components to have <code>Child Slots</code> with same keys. An exception will be thrown if multiple <code>Child Slots</code> with the same key are detected in a component.</p> Two Child Slots in one component<pre><code>class Root(\ncomponentContext: ComponentContext\n) : ComponentContext by componentContext {\n\nprivate val topNavigation = SlotNavigation&lt;TopConfig&gt;()\n\nprivate val topSlot =\nchildSlot&lt;TopConfig, TopChild&gt;(\nsource = topNavigation,\nkey = \"TopSlot\",\n// Omitted code\n)\n\nprivate val bottomNavigation = SlotNavigation&lt;BottomConfig&gt;()\n\nprivate val bottomSlot =\nchildSlot&lt;BottomConfig, BottomChild&gt;(\nsource = bottomNavigation,\nkey = \"BottomSlot\",\n// Omitted code\n)\n}\n</code></pre>"},{"location":"navigation/stack/browser-history/","title":"Web browser history","text":"<p>By default <code>Child Stack</code> navigation does not affect URLs in the browser address bar. But sometimes it is necessary to have different URLs for different <code>Child Stack</code> destinations. For this purpose Decompose provides an experimental API - WebHistoryController.</p> <p>The controller listens for the <code>Child Stack</code> state changes and updates the browser URL and the history accordingly:</p> <ul> <li>When one or more components are pushed to the <code>Child Stack</code> stack, the controller pushes corresponding pages to the history</li> <li>When one or more components are popped from the stack, the controller pops corresponding pages from the history</li> <li>When some components are replaced in the stack, the controller tries its best to keep the page history aligned (there are corner cases)</li> <li>When the user presses the browser's Back button (or selects one of the previous pages in the history dropdown menu), the controller pops the corresponding configurations from the <code>Child Stack</code></li> <li>When the user navigates forward in the browser history, the controller pushes the corresponding configurations to the <code>Child Stack</code></li> </ul>"},{"location":"navigation/stack/browser-history/#corner-cases","title":"Corner cases","text":"<p>There is one known corner case due to the History API limitations. When all configurations in the stack are replaced with another single configuration (<code>A</code>&lt;-<code>B</code>&lt;-<code>C</code> ===&gt; <code>D</code>), the pages corresponding to the second and subsequent removed configurations (<code>B</code> and <code>C</code>) remain in the history. If at this point the user will move forward (by clicking on the Forward button in the browser), the previously removed configurations will be pushed back to the stack (the stack will become <code>D</code>&lt;-<code>B</code> or <code>D</code>&lt;-<code>B</code>&lt;-<code>C</code>).</p>"},{"location":"navigation/stack/browser-history/#limitations","title":"Limitations","text":"<p>Only one <code>Child Stack</code> can be attached to an instance of the <code>WebHistoryController</code>. Having multiple instances of the controller is not allowed.</p>"},{"location":"navigation/stack/browser-history/#configuring-the-application","title":"Configuring the application","text":"<p>Using <code>WebHistoryController</code> in a single page application requires additional configuration - a catch-all strategy to return the same html resource for all paths. This strategy will be different for different server configurations.</p>"},{"location":"navigation/stack/browser-history/#development-configuration","title":"Development configuration","text":"<p>The Kotlin/JS <code>browser</code> target uses webpack-dev-server as a local development server. It can be configured to use the same <code>index.html</code> file (or your primary html file) for all paths, by setting the devServer.historyApiFallback flag. The Gradle DSL for Kotlin webpack currently does not support the <code>historyApiFallback</code> flag, so a special configuration file should be used instead.</p> <p>First, create a directory named <code>webpack.config.d</code> in the JS app module's directory. Then create a new file named <code>devServerConfig.js</code> inside that directory. Finally, put the following content to the file:</p> <pre><code>// &lt;js app module&gt;/webpack.config.d/devServerConfig.js\n\nconfig.devServer = {\n...config.devServer, // Merge with other devServer settings\n\"historyApiFallback\": true\n};\n</code></pre>"},{"location":"navigation/stack/browser-history/#using-the-webhistorycontroller","title":"Using the WebHistoryController","text":"<p>Using <code>WebHistoryController</code> is easy:</p> <ol> <li>Create an instance of <code>DefaultWebHistoryController</code> in the JS app and pass it via constructor to a component responsible for navigation (typically it is the root component).</li> <li>Create <code>Child Stack</code> and use <code>WebHistoryController#historyPaths</code> property for initial stack. This is required for cases when the page is reloaded (refreshed), so that the stack is aligned with te browser history.</li> <li>In the component, call the <code>WebHistoryController.attach</code> method and supply all arguments.</li> <li>In the JS app, pass an initial deeplink to the component.</li> <li>Use the deeplink in the component to generate an initial back stack.</li> </ol>"},{"location":"navigation/stack/browser-history/#example","title":"Example","text":"<p>The sample project demonstrates the use of <code>WebHistoryController</code>:</p> <ul> <li>Main.kt - demonstrates passing <code>WebHistoryController</code> and a deeplink via constructor to <code>RootComponent</code></li> <li>RootComponent - demonstrates generating the initial stack from the deeplink, as well as calling <code>WebHistoryController.attach</code> and supplying the arguments</li> </ul>"},{"location":"navigation/stack/component-context/","title":"Child Stack with custom <code>ComponentContext</code>","text":"<p>Custom <code>ComponentContext</code> allows passing extra data and functionality to every child component. See Custom ComponentContext page for more information about creating custom <code>AppComponentContext</code>.</p> <p>In order to pass custom component context (like <code>AppComponentContext</code>) to child stack components, make an extension function on your <code>AppComponentContext</code> interface. This custom extension function will initialize the <code>Child Stack</code> and provide every child an <code>AppComponentContext</code>.</p> <pre><code>inline fun &lt;reified C : Parcelable, T : Any&gt; AppComponentContext.appChildStack(\nsource: StackNavigationSource&lt;C&gt;,\nnoinline initialStack: () -&gt; List&lt;C&gt;,\nkey: String = \"DefaultStack\",\nhandleBackButton: Boolean = false,\nnoinline childFactory: (configuration: C, AppComponentContext) -&gt; T\n): Value&lt;ChildStack&lt;C, T&gt;&gt; =\nchildStack(\nsource = source,\ninitialStack = initialStack,\nkey = key,\nhandleBackButton = handleBackButton\n) { configuration, componentContext -&gt;\nchildFactory(\nconfiguration,\nDefaultAppComponentContext(\ncomponentContext = componentContext,\n// Additional dependencies here\n)\n)\n}\n</code></pre> <p>Finally, in your components you can use the new extension function that will utilize the custom <code>AppComponentContext</code>.</p> <pre><code>interface RootComponent {\n\nval childStack: Value&lt;ChildStack&lt;*, Child&gt;&gt;\n\nsealed class Child {\nclass ListChild(val component: ItemList) : Child()\nclass DetailsChild(val component: ItemDetails) : Child()\n}\n}\n\nclass DefaultRootComponent(\ncomponentContext: AppComponentContext\n) : RootComponent, AppComponentContext by componentContext {\n\nprivate val navigation = StackNavigation&lt;Config&gt;()\n\noverride val childStack: Value&lt;ChildStack&lt;*, RootComponent.Child&gt;&gt; =\nappChildStack(\nsource = navigation,\ninitialConfiguration = Config.List,\nhandleBackButton = true, // Pop the back stack on back button press\nchildFactory = ::createChild,\n)\n\nprivate fun createChild(config: Config, componentContext: AppComponentContext): RootComponent.Child =\nTODO('Initialize child based on config with the custom component context')\n\nprivate fun itemList(componentContext: AppComponentContext): ItemListComponent =\nTODO('Initialize ItemDetails with the custom component context')\n\nprivate fun itemDetails(componentContext: AppComponentContext, config: Config.Details): ItemDetailsComponent =\nTODO('Initialize ItemDetails with the custom component context')\n\nprivate sealed class Config : Parcelable {\n@Parcelize\nobject List : Config()\n\n@Parcelize\ndata class Details(val itemId: Long) : Config()\n}\n}\n</code></pre>"},{"location":"navigation/stack/deeplinking/","title":"Deep linking","text":"<p>Users following links on devices have one goal in mind: to get to the content they want to see. Decompose provides ability to override initial destinations and back stack. A typical approach is to parse deep links on the platform side and then pass the initial data to the root component and then down the tree to all the required components.</p> <p>Parsing deep links on the platform side is beyond this documentation. This information should be available in the platform's specific documentation. For example here is the related documentation for Android.</p>"},{"location":"navigation/stack/deeplinking/#handling-deep-links","title":"Handling deep links","text":"<p>Given the basic example from the Child Stack overview page, we can easily handle deep links. Let's say we have a link like <code>http://myitems.com?itemId=3</code>. When the user clicks on it, we want to open the details screen of the item with the provided <code>id</code>. When the user closes the details screen, they should be navigated back to the list screen. The idea is to pass parsed data from the deep link to a component responsible for navigation, in our case it is the <code>Root</code> component.</p> <pre><code>class RootComponent(\ncomponentContext: ComponentContext,\ninitialItemId: Long? = null\n) : Root, ComponentContext by componentContext {\n\nprivate val navigation = StackNavigation&lt;Config&gt;()\n\nprivate val stack =\nchildStack(\nsource = navigation,\ninitialStack = {\nlistOfNotNull(\nConfig.List,\nif (initialItemId != null) Config.Details(itemId = initialItemId) else null,\n)\n},\nhandleBackButton = true,\nchildFactory = ::createChild,\n)\n\n// Omitted code\n}\n</code></pre> <p>Now, if the <code>initialItemId</code> is supplied, the initial screen will be the <code>ItemDetails</code> component. The <code>ItemList</code> component will be in the back stack, so the user will be able to go back.</p>"},{"location":"navigation/stack/navigation/","title":"Navigation with Child Stack","text":""},{"location":"navigation/stack/navigation/#the-stacknavigator","title":"The StackNavigator","text":"<p>All navigation in <code>Child Stack</code> is performed using the <code>StackNavigator</code> interface, which is extended by the <code>StackNavigation</code> interface.</p> <p><code>StackNavigator</code> contains the <code>navigate</code> method with the following arguments:</p> <ul> <li><code>transformer</code> - converts the current stack of configurations into a new one. The stack is represented as <code>List</code>, where the last element is the top of the stack, and the first element is the bottom of the stack.</li> <li><code>onComplete</code> - called when navigation is finished.</li> </ul> <p>There is also <code>navigate</code> extension function without the <code>onComplete</code> callback, for convenience.</p> <p>Warning</p> <p>The configuration stack returned by the <code>transformer</code> function must not be empty.</p> Creating the navigation<pre><code>val navigation = StackNavigation&lt;Configuration&gt;()\n</code></pre>"},{"location":"navigation/stack/navigation/#the-navigation-process","title":"The navigation process","text":"<p>During the navigation process, the <code>Child Stack</code> compares the new stack of configurations with the previous one. The <code>Child Stack</code> ensures that all removed components are destroyed, and that there is only one component resumed at a time - the top one. All components in the back stack are always either stopped or destroyed.</p> <p>The <code>Child Stack</code> usually performs the navigation synchronously, which means that by the time the <code>navigate</code> method returns, the navigation is finished and all component lifecycles are moved into required states. However, the navigation is performed asynchronously in case of recursive invocations - e.g. <code>pop</code> is called from <code>onResume</code> lifecycle callback of a component being pushed. All recursive invocations are queued and performed one by one once the current navigation is finished.</p>"},{"location":"navigation/stack/navigation/#stacknavigator-extension-functions","title":"StackNavigator extension functions","text":"<p>There are <code>StackNavigator</code> extension functions to simplify the navigation. Some of which were already used in the Child Stack overview example.</p> <p>The preceding examples will utilize the following <code>sealed class</code> &amp; <code>navigation</code> for showcasing the usage of the <code>StackNavigator</code> extensions.</p> <pre><code>sealed class Configuration {\nobject A : Configuration()\nobject B : Configuration()\nobject C : Configuration()\nobject D : Configuration()\n}\n\nval navigation = StackNavigation&lt;Configuration&gt;()\n</code></pre>"},{"location":"navigation/stack/navigation/#pushconfiguration","title":"push(configuration)","text":"<p>Pushes the provided <code>Configuration</code> at the top of the stack.</p> Before<pre><code>[A, B*]\n</code></pre> <pre><code>navigation.push(Configuration.C)\n</code></pre> After<pre><code>[A, B, C*]\n</code></pre>"},{"location":"navigation/stack/navigation/#pop","title":"pop","text":"<p>Pops the latest configuration at the top of the stack.</p> Before<pre><code>[A, B, C*]\n</code></pre> <pre><code>navigation.pop()\n\n// Or\n\nnavigation.pop { isSuccess -&gt;\n// Called when the navigation is finished.\n// isSuccess - `true` if the stack size was greater than 1 and a component was popped, `false` otherwise.\n}\n</code></pre> After<pre><code>[A, B*]\n</code></pre>"},{"location":"navigation/stack/navigation/#popwhilepredicate","title":"popWhile(predicate)","text":"<p>Drops the configurations at the top of the stack while the provided predicate returns true.</p> Before<pre><code>[A, B, C, D*]\n</code></pre> <pre><code>navigation.popWhile { topOfStack: Configuration -&gt; topOfStack !is B }\n</code></pre> After<pre><code>[A, B*]\n</code></pre>"},{"location":"navigation/stack/navigation/#poptoindex","title":"popTo(index)","text":"<p>Drops configurations at the top of the stack so that the provided index becomes active (the new top of the stack).</p> Before<pre><code>[A, B, C, D*]\n</code></pre> <pre><code>navigation.popTo(index = 1)\n</code></pre> After<pre><code>[A, B*]\n</code></pre>"},{"location":"navigation/stack/navigation/#replacecurrentconfiguration","title":"replaceCurrent(configuration)","text":"<p>Replaces the current configuration at the top of the stack with the provided <code>Configuration</code>.</p> Before<pre><code>[A, B, C*]\n</code></pre> <pre><code>navigation.replaceCurrent(Configuration.D)\n</code></pre> After<pre><code>[A, B, D*]\n</code></pre>"},{"location":"navigation/stack/navigation/#replaceallvararg-configurations","title":"replaceAll(vararg configurations)","text":"<p>Replaces all configurations currently in the stack with the provided configurations. Components that remain in the stack are not recreated, components that are no longer in the stack are destroyed.</p> Before<pre><code>[A, B, C*]\n</code></pre> <pre><code>navigation.replaceAll(Configuration.B, Configuration.C, Configuration.D)\n</code></pre> After<pre><code>[B, C, D*]\n</code></pre>"},{"location":"navigation/stack/navigation/#bringtofrontconfiguration","title":"bringToFront(configuration)","text":"<p>Removes all components with configurations of the provided <code>Configuration</code>'s class, and adds the provided <code>Configuration</code> to the top of the stack. This is primarily helpful when implementing a Decompose app with Bottom Navigation. See the related discussion in the old repository.</p> <p>Note</p> <p>The operation is performed as one transaction. If there is already a component with the same configuration, it will not be recreated.</p> Before<pre><code>[A, B, C*]\n</code></pre> <pre><code>navigation.bringToFront(Configuration.B)\n</code></pre> After<pre><code>[A, C, B*]\n</code></pre>"},{"location":"navigation/stack/overview/","title":"Child Stack overview","text":""},{"location":"navigation/stack/overview/#the-child-stack","title":"The Child Stack","text":"<p><code>Child Stack</code> is a navigation model for managing a stack of components, just like <code>FragmentManager</code>.</p> <p>Each component has its own <code>Lifecycle</code>. Each time a new component is pushed to the stack, the currently active component is stopped. When a component is popped from the stack, the previous component is resumed. This allows business logic to run while the component is in the back stack. It is possible to have more than one <code>Child Stack</code> in a component, nested stacks are also supported.</p> <p>The <code>Child Stack</code> navigation consists of two main entities:</p> <ul> <li>ChildStack - a simple data class that stores a stack of components and their configurations.<ul> <li>ChildStack#active - contains the currently active component.</li> <li>ChildStack#backStack - contains the back stack of inactive components.</li> </ul> </li> <li>StackNavigation - an interface that accepts navigation commands and forwards them to all subscribed observers.</li> </ul>"},{"location":"navigation/stack/overview/#component-configurations","title":"Component Configurations","text":"<p>Each component created and managed by the <code>Child Stack</code> has a configuration, please read the documentation about child configurations.</p> <p><code>Child Stack</code> adds one additional requirement for child configurations:</p> <ul> <li>Configurations must be unique (by equality) within the <code>Child Stack</code>.</li> </ul>"},{"location":"navigation/stack/overview/#initializing-the-child-stack","title":"Initializing the Child Stack","text":"<p>There are three steps to initialize the <code>Child Stack</code>:</p> <ul> <li>Create a new instance of <code>StackNavigation</code> and assign it to a variable or a property.</li> <li>Initialize the <code>Child Stack</code> using the <code>ComponentContext#childStack</code> extension function and pass <code>StackNavigation</code> into it along with other arguments.</li> <li>The <code>childStack</code> function returns <code>Value&lt;ChildStack&gt;</code> that can be observed in the UI. Assign the returned <code>Value</code> to another property or a variable.</li> </ul>"},{"location":"navigation/stack/overview/#example","title":"Example","text":"<p>Here is a very basic example of navigation between two child components:</p> ItemList component<pre><code>interface ItemListComponent {\n\n// Omitted code\n\nfun onItemClicked(id: Long)\n}\n\nclass DefaultItemListComponent(\ncomponentContext: ComponentContext,\nprivate val onItemSelected: (id: Long) -&gt; Unit\n) : ItemListComponent, ComponentContext by componentContext {\n\n// Omitted code\n\noverride fun onItemClicked(id: Long) {\nonItemSelected(id)\n}\n}\n</code></pre> ItemDetails component<pre><code>interface ItemDetailsComponent {\n\n// Omitted code\n\nfun onCloseClicked()\n}\n\nclass DefaultItemDetailsComponent(\ncomponentContext: ComponentContext,\nitemId: Long,\nprivate val onFinished: () -&gt; Unit\n) : ItemDetailsComponent, ComponentContext by componentContext {\n\n// Omitted code\n\noverride fun onCloseClicked() {\nonFinished()\n}\n}\n</code></pre> Root component<pre><code>interface RootComponent {\n\nval childStack: Value&lt;ChildStack&lt;*, Child&gt;&gt;\n\nsealed class Child {\nclass ListChild(val component: ItemList) : Child()\nclass DetailsChild(val component: ItemDetails) : Child()\n}\n}\n\nclass DefaultRootComponent(\ncomponentContext: ComponentContext\n) : RootComponent, ComponentContext by componentContext {\n\nprivate val navigation = StackNavigation&lt;Config&gt;()\n\noverride val childStack: Value&lt;ChildStack&lt;*, RootComponent.Child&gt;&gt; =\nchildStack(\nsource = navigation,\ninitialConfiguration = Config.List,\nhandleBackButton = true, // Pop the back stack on back button press\nchildFactory = ::createChild,\n)\n\nprivate fun createChild(config: Config, componentContext: ComponentContext): RootComponent.Child =\nwhen (config) {\nis Config.List -&gt; ListChild(itemList(componentContext))\nis Config.Details -&gt; DetailsChild(itemDetails(componentContext, config))\n}\n\nprivate fun itemList(componentContext: ComponentContext): ItemListComponent =\nDefaultItemListComponent(\ncomponentContext = componentContext,\nonItemSelected = { navigation.push(Config.Details(itemId = it)) }\n)\n\nprivate fun itemDetails(componentContext: ComponentContext, config: Config.Details): ItemDetailsComponent =\nDefaultItemDetailsComponent(\ncomponentContext = componentContext,\nitemId = config.itemId,\nonFinished = { navigation.pop() }\n)\n\nprivate sealed class Config : Parcelable {\n@Parcelize\nobject List : Config()\n\n@Parcelize\ndata class Details(val itemId: Long) : Config()\n}\n}\n</code></pre>"},{"location":"navigation/stack/overview/#components-in-the-back-stack","title":"Components in the back stack","text":"<p><code>Child Stack</code> can not be empty, there is always one active (resumed) child component. Components in the back stack are always stopped. When <code>Child Stack</code> is first initialized or recreated after e.g. process death, all components are automatically created and the active component is resumed.</p>"},{"location":"navigation/stack/overview/#screen-recreation-and-process-death-on-not-only-android","title":"Screen recreation and process death on (not only) Android","text":"<p><code>Child Stack</code> automatically preserves the stack when a configuration change or process death occurs. Use the <code>persistent</code> argument to disable stack preservation completely. When disabled, the stack is reset to the initial state when recreated.</p> <p>Components are created in their order. E.g. the first component in the back stack is created first, then the next component in the back stack is created, and so on. The active component is the latest component created.</p> <p>Components are destroyed in reverse order, e.g. the active component is destroyed first, then the last component in the back stack is destroyed, and so on.</p>"},{"location":"navigation/stack/overview/#delivering-a-result-when-navigating-back","title":"Delivering a result when navigating back","text":"<p>To deliver a result from one component to another:</p> <ul> <li>Pass a callback to the <code>second</code> component.</li> <li>Call the callback with a <code>result</code> from the <code>second</code> component.</li> <li>In the <code>parent</code> component, supply the callback when instantiating the <code>second</code> component.</li> <li>When the callback is invoked, perform the navigation, e.g. by using <code>navigation.pop { ... }</code>.</li> <li>After the navigation is performed, call a method on the <code>first</code> component with the <code>result</code>.</li> </ul> <pre><code>interface ItemListComponent {\n\nfun onItemClicked(id: Long)\n\nfun onItemDeleted(id: Long)\n}\n\ninterface ItemDetailsComponent {\n\nfun onDeleteClicked()\n}\n\nclass DefaultItemListComponent(\ncomponentContext: ComponentContext,\nprivate val onItemSelected: (id: Long) -&gt; Unit,\n) : ItemListComponent, ComponentContext by componentContext {\n\noverride fun onItemClicked(id: Long) {\nonItemSelected(id)\n}\n\noverride fun onItemDeleted(id: Long) {\n// TODO: Handle item deleted\n}\n}\n\nclass DefaultItemDetailsComponent(\ncomponentContext: ComponentContext,\nprivate val itemId: Long,\nprivate val onDeleted: (itemId: Long) -&gt; Unit\n) : ItemDetailsComponent, ComponentContext by componentContext {\n\noverride fun onDeleteClicked() {\n// TODO: Delete the item\nonDeleted(itemId = itemId)\n}\n}\n\nclass DefaultRootComponent(\ncomponentContext: ComponentContext\n) : RootComponent, ComponentContext by componentContext {\n\n// Omitted code\n\nprivate fun itemList(componentContext: ComponentContext): ItemListComponent =\nDefaultItemListComponent(\ncomponentContext = componentContext,\nonItemSelected = { navigation.push(Config.Details(itemId = it)) }\n)\n\nprivate fun itemDetails(componentContext: ComponentContext, config: Config.Details): ItemDetailsComponent =\nDefaultItemDetailsComponent(\ncomponentContext = componentContext,\nitemId = config.itemId,\nonDeleted = { itemId -&gt;\nnavigation.pop { // Pop ItemDetails component\n// Deliver the result to ItemList component\n(stack.value.active.instance as? ItemList)?.onItemDeleted(id = itemId)\n}\n}\n)\n\n// Omitted code\n}\n</code></pre>"},{"location":"navigation/stack/overview/#alternative-way","title":"Alternative way","text":"<p>It is also possible to deliver results using reactive streams - e.g. coroutines <code>Flow</code> or Rx <code>Observable</code>.</p> <p>Here is an example using Reaktive library. Kotlin coroutines <code>SharedFlow</code> should be very similar.</p> <pre><code>interface ItemListComponent {\n\nfun onItemClicked(id: Long)\n\nsealed interface Input {\nclass ItemDeleted(val id: Long) : Input\n}\n}\n\ninterface ItemDetailsComponent {\n\nfun onDeleteClicked()\n}\n\n// Helper factory function creating DisposableScope attached to the Lifecycle.\n// Creating CoroutineScope is very similar.\nfun LifecycleOwner.disposableScope(): DisposableScope {\nval scope = DisposableScope()\nlifecycle.doOnDestroy(scope::dispose)\nreturn scope\n}\n\nclass DefaultItemListComponent(\ncomponentContext: ComponentContext,\ninput: Observable&lt;ItemList.Input&gt;,\nprivate val onItemSelected: (id: Long) -&gt; Unit,\n) : ItemListComponent, ComponentContext by componentContext, DisposableScope by componentContext.disposableScope() {\n\ninit {\n// Subscribe to input\ninput.subscribeScoped {\nwhen (it) {\nis ItemList.Input.ItemDeleted -&gt; TODO(\"Handle item deleted\")\n}\n}\n}\n\noverride fun onItemClicked(id: Long) {\nonItemSelected(id)\n}\n}\n\nclass DefaultRootComponent(\ncomponentContext: ComponentContext\n) : RootComponent, ComponentContext by componentContext {\n\n// Omitted code\n\n// Or MutableSharedFlow&lt;ItemList.Input&gt;(extraBufferCapacity = Int.MAX_VALUE)\nprivate val listInput = PublishSubject&lt;ItemList.Input&gt;()\n\nprivate fun itemList(componentContext: ComponentContext): DefaultItemListComponent =\nDefaultItemListComponent(\ncomponentContext = componentContext,\ninput = listInput, // Pass listInput to ItemListComponent\nonItemSelected = { navigation.push(Config.Details(itemId = it)) },\n)\n\nprivate fun itemDetails(componentContext: ComponentContext, config: Config.Details): ItemDetailsComponent =\nDefaultItemDetailsComponent(\ncomponentContext = componentContext,\nitemId = config.itemId,\nonItemDeleted = { id -&gt;\nnavigation.pop { // Pop ItemDetails component\n// Deliver the result to ItemList component\nlistInput.onNext(ItemList.Input.ItemDeleted(id = id))\n}\n},\n)\n\n// Omitted code\n}\n</code></pre>"},{"location":"navigation/stack/overview/#multiple-child-stacks-in-a-component","title":"Multiple Child Stacks in a component","text":"<p>When multiple <code>Child Stacks</code> are used in one component, each such <code>Child Stack</code> must have a unique key associated. The keys are required to be unique only within the parent (hosting) component, so it is ok for different components to have <code>Child Stacks</code> with same keys. An exception will be thrown if multiple <code>Child Stacks</code> with the same key are detected in a component.</p> Two Child Stacks in one component<pre><code>class DefaultRootComponent(\ncomponentContext: ComponentContext\n) : RootComponent, ComponentContext by componentContext {\n\nprivate val topNavigation = StackNavigation&lt;TopConfig&gt;()\n\nprivate val topStack =\nchildStack&lt;TopConfig, TopChild&gt;(\nsource = topNavigation,\nkey = \"TopStack\",\n// Omitted code\n)\n\nprivate val bottomNavigation = StackNavigation&lt;BottomConfig&gt;()\n\nprivate val bottomStack =\nchildStack&lt;BottomConfig, BottomChild&gt;(\nsource = bottomNavigation,\nkey = \"BottomStack\",\n// Omitted code\n)\n}\n</code></pre>"}]}